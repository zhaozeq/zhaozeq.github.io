<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jQuery由来</title>
    <url>/2017/03/06/1.jQuery()%E5%92%8C$()%E7%9A%84%E7%94%B1%E6%9D%A5/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">jQuery = <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	alert(a);</span><br><span class="line">&#125;</span><br><span class="line">$=<span class="built_in">window</span>.jQuery = jQuery;</span><br><span class="line"></span><br><span class="line">$(a);</span><br><span class="line">jQuery(a);</span><br></pre></td></tr></table></figure>
<p>嗯 好像是这么回事 哈哈~~</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>理解merge和pushStack可以更好的了解jQuery源码</title>
    <url>/2017/03/06/2.%E7%90%86%E8%A7%A3merge%E5%92%8CpushStack%E5%8F%AF%E4%BB%A5%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BA%86%E8%A7%A3jQuery%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;我就想看看自己JS学到什么程度然后让自己对jquery方法有更深的印象就“作死着”去看了看jquery源码，毕竟都说其编码结构很NB…<br>&nbsp;&nbsp;&nbsp;&nbsp;目前还只看到前面一部分，基本是在<em>jQuery</em>构造方法下 定义了一些变量和方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;然后发现 <code>merge()</code> 和 <code>pushStack()</code> 出现多次,然后就去看了这两个方法，相信对大家也会很有用的。<br><a id="more"></a></p>
<p>####merge源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/****</span><br><span class="line">	这个代码其实很容易理解，就是把第二个对象的属性附加到第一个上去，</span><br><span class="line">	其实就是返回一个合并后的数组</span><br><span class="line">***/</span><br><span class="line">merge: function( first, second ) &#123;</span><br><span class="line">		var len = +second.length,</span><br><span class="line">			j = 0,</span><br><span class="line">			i = first.length;</span><br><span class="line"></span><br><span class="line">		for ( ; j &lt; len; j++ ) &#123;</span><br><span class="line">			first[ i++ ] = second[ j ];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		first.length = i;</span><br><span class="line"></span><br><span class="line">		return first;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>####pushStack源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/****</span><br><span class="line">	来到pushStack函数，其作用是将一个DOM元素集合加入到jQuery栈。</span><br><span class="line">	这里需要讲一下*this.constructor()*其实就是jQuery的构造函数init，所以this.constructor()返回一个jQuery对象，将当前元素elems通过merge方法合并，完成入栈。并且在ret上添加了prevObject属性，使得上一个对象得以保存，可以通过对象的prevObject属性去到上一级对象。</span><br><span class="line">***/</span><br><span class="line">	pushStack: function( elems ) &#123;</span><br><span class="line"></span><br><span class="line">		var ret = jQuery.merge( this.constructor(), elems );</span><br><span class="line"></span><br><span class="line">		ret.prevObject = this;</span><br><span class="line"></span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>####例如eq()方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*当找到匹配元素时将其放入堆栈，否则返回空对象**/</span><br><span class="line">eq: function( i ) &#123;</span><br><span class="line">		var len = this.length,</span><br><span class="line">			j = +i + ( i &lt; 0 ? len : 0 );</span><br><span class="line">		return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] );</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>组建通信的双向绑定问题</title>
    <url>/2017/09/06/VueAvoid%20mutating%20a%20prop%20directly%20since%20the%20value%20will%20be%20overwritten%20...%E8%AD%A6%E5%91%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="这个问题的本质还是组建通信的双向绑定问题"><a href="#这个问题的本质还是组建通信的双向绑定问题" class="headerlink" title="这个问题的本质还是组建通信的双向绑定问题"></a>这个问题的本质还是组建通信的双向绑定问题</h3><p>####在<a href="https://cn.vuejs.org/v2/guide/components.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">vue2.0文档</a>中有这么一段话：</p>
<blockquote>
<p>&nbsp;&nbsp; 在一些情况下，我们可能会需要对一个 prop 进行『双向绑定』。事实上，这正是 Vue 1.x 中的 .sync修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了『单向数据流』的假设。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。<br>上面所说的正是我们在 2.0 中移除 .sync 的理由。但是在 2.0 发布之后的实际应用中，我们发现 .sync 还是有其适用之处，比如在开发可复用的组件库时。我们需要做的只是让子组件改变父组件状态的代码更容易被区分。<br>&nbsp;&nbsp;从 2.3.0 起我们重新引入了 .sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。</p>
</blockquote>
<h3 id="1-sync方法"><a href="#1-sync方法" class="headerlink" title="1..sync方法"></a>1.<code>.sync</code>方法</h3><p>也就是说，如果你用的vue版本是2.3.0+，那么你可以放心使用<code>.sync</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;</span><br><span class="line"></span><br><span class="line">会被扩展为：</span><br><span class="line">&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;</span><br><span class="line"></span><br><span class="line">当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</span><br><span class="line">this.$emit(&apos;update:foo&apos;, newValue)</span><br></pre></td></tr></table></figure></p>
<p>这就是props传入和emit传出的过程</p>
<p>##</p>
<p>###2.对象特性<br>使用对象的引用特性完成的双向绑定<br>因此我们可以传入对象，然后在子组件中修改对象属性的值那么父组件中该值也会发生变化</p>
<p>##</p>
<p>###3.vuex<br>当我们的项目比较复杂时就很有必要用到vuex了<br><a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">vuex文档</a><br>这里简单的理一下顺序<br>vuex中有mapAction和mapGettters两个方法</p>
<p>|=》通过mapAction把函数传递出去</p>
<p>|=》在actions中 利用内置commit=》mutations</p>
<p>|=》在mutations引入getters（这个类似store的计算属性） 定义state状态，然后通过mutations来改变state，最后导出state,mutations,getters…发现自己讲不太清楚哈哈~还是看文档吧 慢慢悟好好学~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;CLOSE, IS_SHOW ,REG_SHOW,ABOUT_SHOW,SHOW&#125; from &quot;./types&quot;; </span><br><span class="line">import getters from &apos;./getters&apos;</span><br><span class="line">	const state = &#123;</span><br><span class="line">	  close:false,</span><br><span class="line">	  state:0,</span><br><span class="line">	  isShow:false</span><br><span class="line">	&#125;;</span><br><span class="line">	const mutations = &#123;</span><br><span class="line">	  [IS_SHOW](state)&#123;</span><br><span class="line">	    state.state = 1;</span><br><span class="line">	    state.isShow = !state.isShow;</span><br><span class="line">	  &#125;</span><br><span class="line">	  export default &#123;</span><br><span class="line">	  state,</span><br><span class="line">	  mutations,</span><br><span class="line">	  getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[TOC]</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery 拓展方法</title>
    <url>/2017/03/06/3.jQuery%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95extend();/</url>
    <content><![CDATA[<p>####<strong>1.当只写一个对象自变量的时候，JQ中扩展插件的形式</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.extend(&#123;     <span class="comment">//扩展工具方法</span></span><br><span class="line">	fun1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;,</span><br><span class="line">	fun2 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//调用:  $.fun1()</span></span><br><span class="line"><span class="comment">/*那么为什么可以这么调用呢？</span></span><br><span class="line"><span class="comment">	$.extend() 它的this是$,因此this.fun1()==$.fun1();	</span></span><br><span class="line"><span class="comment">**/</span> </span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">$.fn.extend(&#123;     <span class="comment">//扩展JQ实例方法</span></span><br><span class="line">	fun1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;,</span><br><span class="line">	fun2 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//调用:  $().fun1() </span></span><br><span class="line"><span class="comment">/*那么为什么可以这么调用呢？</span></span><br><span class="line"><span class="comment">	$.fn.extend() 它的this是$.fn,因此this.fun1()==$().fun1();	</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<p>####<strong>2.当写多个对象自变量的时候 , 后面的对象都是扩展到第一个对象身上</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">$.extend( a , &#123; <span class="attr">name</span> : <span class="string">'hello'</span> &#125; , &#123; <span class="attr">age</span> : <span class="number">30</span> &#125;,... );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a );<span class="comment">//a=&#123;name:'hello', age : 30,...&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<p>####<strong>3.还可以做  浅拷贝 和 深拷贝</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &#123;&#125;;</span><br><span class="line">var b = &#123;  name : &apos;张三&apos; &#125; ;</span><br><span class="line">$.extend( a , b );</span><br><span class="line">a.name = &apos;hi&apos;;</span><br><span class="line">alert( b.name);//张三  这就是</span><br><span class="line"></span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">var b = &#123;  name : &#123; age : 30 &#125; &#125;;</span><br><span class="line">a.name.age = 20;</span><br><span class="line">alert( b.name.age );//20  此时就会受到影响</span><br><span class="line"></span><br><span class="line">//而深拷贝只需要在前面加个true 如下：</span><br><span class="line">$.extend( true , a , b ); //此时继承是不会受到影响的！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JQ中 : 拷贝继承 : 构造函数的原型</span><br><span class="line"></span><br><span class="line">JS : 类式继承 / 原型继承</span><br><span class="line"></span><br><span class="line">new 构造函数   /  &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>####<strong>4.extend()中的属性和方法汇总</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">	</span><br><span class="line">	expando  :  生成唯一JQ字符串(内部)</span><br><span class="line">	noConflict()  :  防止冲突</span><br><span class="line">	isReady  :  DOM是否加载完(内部)</span><br><span class="line">	readyWait  :  等待多少文件的计数器(内部)</span><br><span class="line">	holdReady()  :  推迟DOM触发</span><br><span class="line">	ready()  :  准备DOM触发</span><br><span class="line">	isFunction()  :  是否为函数</span><br><span class="line">	isArray()  :  是否为数组</span><br><span class="line">	isWindow()  :  是否为window</span><br><span class="line">	isNumeric()  :  是否为数字 </span><br><span class="line">	type()  :  判断数据类型</span><br><span class="line">	isPlainObject()  :  是否为对象自变量</span><br><span class="line">	isEmptyObject()  :  是否为空的对象</span><br><span class="line">	error()  :  抛出异常</span><br><span class="line">	parseHTML()  :  解析节点</span><br><span class="line">	parseJSON()  :  解析JSON</span><br><span class="line">	parseXML()  :  解析XML</span><br><span class="line">	noop()  :  空函数</span><br><span class="line">	globalEval()  :  全局解析JS</span><br><span class="line">	camelCase()  :  转驼峰(内部)</span><br><span class="line">	nodeName()  :  是否为指定节点名(内部)</span><br><span class="line">	each()  :  遍历集合</span><br><span class="line">	trim()  :  去前后空格</span><br><span class="line">	makeArray()  :  类数组转真数组</span><br><span class="line">	inArray()  :  数组版indexOf</span><br><span class="line">	merge()  :  合并数组</span><br><span class="line">	grep()  :  过滤新数组</span><br><span class="line">	map()  :  映射新数组</span><br><span class="line">	guid  :  唯一标识符(内部)</span><br><span class="line">	proxy()  :  改this指向</span><br><span class="line">	access()  :  多功能值操作(内部)</span><br><span class="line">	now()  :  当前时间</span><br><span class="line">	swap()  :  CSS交换(内部)</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue +Node +Mysql 从简至全（一）</title>
    <url>/2017/11/06/Vue%20+Node%20+Mysql%20%E4%BB%8E%E7%AE%80%E8%87%B3%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>##简单的后端接口连接的实现</p>
<blockquote>
<p>–这一部分是实现后端的接口，接下来会依次实现数据库操作和前后端数据交互过程。</p>
</blockquote>
<p>后端：</p>
<ol>
<li><p><code>npm install express mysql -S</code></p>
</li>
<li><p>编写后端入口文件（app.js）：</p>
<p><img src="http://img.blog.csdn.net/20171011104140855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY1NzE2MDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="入口文件"></p>
</li>
<li><p>编写路由文件：<br><img src="http://img.blog.csdn.net/20171011104511699?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY1NzE2MDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="路由文件"></p>
</li>
<li><p><code>node app.js</code> 这个时候最简单的后台接口就启动了，可以<a href="http://localhost:3000/test访问到该接口" target="_blank" rel="noopener">http://localhost:3000/test访问到该接口</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>node</tag>
        <tag>Mysql</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue +Node +Mysql 从简至全（二）</title>
    <url>/2017/11/06/Vue%20+Node%20+Mysql%20%E4%BB%8E%E7%AE%80%E8%87%B3%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>##简单的后端接口连接的实现</p>
<blockquote>
<p>–这一部分是实现后端的接口，接下来会依次实现数据库操作和前后端数据交互过程。</p>
</blockquote>
<p>后端：</p>
<ol>
<li><p><code>npm install express mysql -S</code></p>
</li>
<li><p>编写后端入口文件（app.js）：</p>
<p><img src="http://img.blog.csdn.net/20171011104140855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY1NzE2MDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="入口文件"></p>
</li>
<li><p>编写路由文件：<br><img src="http://img.blog.csdn.net/20171011104511699?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY1NzE2MDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="路由文件"></p>
</li>
<li><p><code>node app.js</code> 这个时候最简单的后台接口就启动了，可以<a href="http://localhost:3000/test访问到该接口" target="_blank" rel="noopener">http://localhost:3000/test访问到该接口</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>node</tag>
        <tag>Mysql</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>fullPage代码从基层往上爬（一）</title>
    <url>/2017/10/07/fullPage%E4%BB%A3%E7%A0%81%E4%BB%8E%E5%9F%BA%E5%B1%82%E5%BE%80%E4%B8%8A%E7%88%AC%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>自己打算通过fullPage.js来好好巩固滚轮事件、兼容性实现、jquery、函数封装等等….<br>这一部分先完成fullPage的基础功能，接下来就会进行封装、优雅降级、添加功能等…</p>
<ul>
<li><strong>html代码结构</strong></li>
<li><strong>css布局</strong></li>
<li><strong>jquery实现基础功能</strong></li>
</ul>
<hr>
<h3 id="html代码结构"><a href="#html代码结构" class="headerlink" title="html代码结构"></a>html代码结构</h3><p>最简单的结构，就不做详细说明了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;section-group&quot;&gt;</span><br><span class="line">  &lt;section class=&quot;area-01&quot; data-title=&quot;标题一&quot;&gt;&lt;h2&gt;标题一&lt;/h2&gt;&lt;/section&gt;</span><br><span class="line">  &lt;section class=&quot;area-02&quot; data-title=&quot;标题二&quot;&gt;&lt;h2&gt;标题二&lt;/h2&gt;&lt;/section&gt;</span><br><span class="line">  &lt;section class=&quot;area-03&quot; data-title=&quot;标题三&quot;&gt;&lt;h2&gt;标题三&lt;/h2&gt;&lt;/section&gt;</span><br><span class="line">  &lt;section class=&quot;area-04&quot; data-title=&quot;标题四&quot;&gt;&lt;h2&gt;标题四&lt;/h2&gt;&lt;/section&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<p>###css布局<br>布局也简单,挑重点贴<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	.section-group&#123;</span><br><span class="line">	  width:100%;height:100%;position:relative;</span><br><span class="line">	  -webkit-transition:1s cubic-bezier(.74,0,.2,1);</span><br><span class="line">	  transition:1s cubic-bezier(.74,0,.2,1);</span><br><span class="line">	&#125;</span><br><span class="line">	.section-group &gt;section&#123;</span><br><span class="line">	  width:100%;height:100%;overflow:hidden;</span><br><span class="line">	&#125;</span><br><span class="line">/*右边的ul条**/</span><br><span class="line">.pagination &#123;</span><br><span class="line">		position: absolute;</span><br><span class="line">		top: 50%;</span><br><span class="line">		transform: translateY(-25%);</span><br><span class="line">		right: 50px;</span><br><span class="line">		z-index: 999;</span><br><span class="line">	&#125;</span><br><span class="line">	.pagination &gt;li&#123;</span><br><span class="line">	  width:14px;height:14px;background:rgba(0,0,0,.6);margin:16px 0; </span><br><span class="line">	  border-radius:50%;cursor:pointer;position:relative;</span><br><span class="line">	  list-style:none;</span><br><span class="line">	&#125;</span><br><span class="line">	.pagination &gt;li &gt;span&#123;</span><br><span class="line">		line-height:26px;background:rgba(0,0,0,.6);border-radius:13px;</span><br><span class="line">		white-space:nowrap;font-size:12px;color:#fff;opacity:0;</span><br><span class="line">		-webkit-transition:.6s;transition:.6s;</span><br><span class="line">		-webkit-transform:translateX(20px);transform:translateX(20px);</span><br><span class="line">	&#125;</span><br><span class="line">	.pagination &gt;li:hover &gt;span,.pagination &gt;li.active &gt;span&#123;</span><br><span class="line">	  opacity:1;-webkit-transform:translateX(0);transform:translateX(0);&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<p>###jquery实现基础功能<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 这里还只支持IE8+ */</span><br><span class="line">$(function()&#123;</span><br><span class="line">	var group = $(&apos;.section-group&apos;);</span><br><span class="line">	var sections = group.find(&apos;section&apos;);</span><br><span class="line">	var sectionLength = sections.length;</span><br><span class="line">	var index = 0,translateY;onMove=false;</span><br><span class="line">	</span><br><span class="line">	//侧边</span><br><span class="line">	var pagination = function()&#123;</span><br><span class="line">		var lis = [&apos;&lt;ul class=\&quot;pagination\&quot;&gt;&apos;];</span><br><span class="line">		for(var i = 0;i&lt;sectionLength;i++)&#123;</span><br><span class="line">			title = sections.eq(i).data(&apos;title&apos;);//data-title</span><br><span class="line">			lis.push(&apos;&lt;li&gt;&lt;span&gt;&apos;+ (title?title:&apos;&apos;) +&apos;&lt;/span&gt;&lt;/li&gt;&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">		lis.push(&apos;&lt;/ul&gt;&apos;);</span><br><span class="line">		return lis.join(&apos;&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	$(&quot;body&quot;).append(pagination());</span><br><span class="line">	$(&quot;ul.pagination&gt;li&quot;).eq(0).addClass(&apos;active&apos;);//默认第一个li选中</span><br><span class="line">	$(&quot;ul.pagination&gt;li&quot;).click(function()&#123;      //li点击事件编写</span><br><span class="line">		if(onMove)&#123;return;&#125; </span><br><span class="line">		var _this = $(this);</span><br><span class="line">		_this.addClass(&apos;active&apos;);</span><br><span class="line">		_this.siblings().removeClass(&apos;active&apos;);</span><br><span class="line">		index = _this.index();</span><br><span class="line">		translateY = index*100;</span><br><span class="line">		onMove = true;</span><br><span class="line">		group.css(&#123;</span><br><span class="line">		&apos;-webkit-transform&apos;:&apos;translateY(-&apos;+ translateY +&apos;%)&apos;,</span><br><span class="line">        &apos;transform&apos;:&apos;translateY(-&apos;+ translateY +&apos;%)&apos;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		setTimeout(function () &#123;//为了防止滚轮时间不断被触发</span><br><span class="line">		 onMove = false;</span><br><span class="line">		&#125;, 500);</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// jquery 兼容的滚轮事件</span><br><span class="line">	$(document).on(&quot;mousewheel DOMMouseScroll&quot;, function (e) &#123;	</span><br><span class="line">		if(onMove)&#123;return;&#125;	</span><br><span class="line">		var delta = (e.originalEvent.wheelDelta &amp;&amp; (e.originalEvent.wheelDelta &gt; 0 ? 1 : -1)) ||  // chrome &amp; ie</span><br><span class="line">					(e.originalEvent.detail &amp;&amp; (e.originalEvent.detail &gt; 0 ? -1 : 1));              // firefox</span><br><span class="line">		if (delta &gt; 0) &#123;</span><br><span class="line">			if(index&lt;=0)&#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;index--;&#125;</span><br><span class="line">			$(&quot;ul.pagination&gt;li&quot;).eq(index).click();</span><br><span class="line">		&#125; else if (delta &lt; 0) &#123;</span><br><span class="line">			if(index&gt;sectionLength-2)&#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;index++;&#125;</span><br><span class="line">			</span><br><span class="line">			$(&quot;ul.pagination&gt;li&quot;).eq(index).click();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>javascript</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>SVG路径描边动画效果</title>
    <url>/2017/11/06/SVG%E8%B7%AF%E5%BE%84%E6%8F%8F%E8%BE%B9%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio部分<br>参考自: <a href="http://www.w3cplus.com/html5/svg-coordinate-systems.html" target="_blank" rel="noopener">http://www.w3cplus.com/html5/svg-coordinate-systems.html</a> © w3cplus.com</p>
</blockquote>
<p>先来放一个自己写的效果：<br><img src="http://img.blog.csdn.net/20170909140356663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY1NzE2MDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>是不是很酷！！！</p>
<p>###一、先看下svg几个属性：</p>
<p>####1.<code>stroke:none | currentColor | &lt;color&gt;</code>(描边颜色)<br>    none:        没有颜色<br>    <color>:     常规的颜色值。RGBA, HSBA都支持。<br>    currentColor:可以让路径绘制的文字直接继承父标签的color颜色值。<br><code>stroke-width 表示描边的粗细。</code></color></p>
<p><code>stroke-linecap 表示描边端点表现方式。可用值有：butt, round, square, inherit.</code></p>
<p><code>stroke-linejoin 表示描边转角的表现方式。可用值有：miter, round, bevel, inherit.</code></p>
<p><code>stroke-miterlimit 表示描边相交（锐角）的表现方式。默认大小是4.</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stroke-dasharray 表示虚线描边。可选值为：none, &lt;dasharray&gt;, inherit. </span><br><span class="line"></span><br><span class="line">none表示不是虚线；</span><br><span class="line">&lt;dasharray&gt;为一个逗号或空格分隔的数值列表。表示各个虚线段的长度。可以是固定的长度值，也可以是百分比值；</span><br><span class="line">inherit表继承。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stroke-dashoffset 表示虚线的起始偏移。可选值为：&lt;percentage&gt;, &lt;length&gt;, inherit. 百分比值，长度值，继承。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stroke-opacity 表示描边透明度。默认是1.</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<p>####2.SVG坐标系和变换：viewport,viewBox和preserveAspectRatio</p>
<ul>
<li><p>viewport：<br>你可以在最外层<svg>元素上使用width和height属性声明视窗尺寸<br/>视窗的初始坐标原点(0,0)在视窗的左上角，<code>X</code>轴正向指向右，<code>Y</code>轴正向指向下，初始坐标系中的一个单位等于视窗中的一个”像素”。</svg></p>
</li>
<li><p>viewBox：这个可以声明自己的用户坐标系。<br>viewBox属性接收四个参数值，包括：<code>&lt;min-x&gt;</code>, <code>&lt;min-y&gt;</code>, <code>width</code> 和 <code>height</code>。<br><code>&lt;min-x&gt;</code> 和 <code>&lt;min-y&gt;</code> 值决定viewBox的左上角，<code>width</code>和<code>height</code>决定视窗的宽高。这里要注意视窗的宽高不一定和父<code>&lt;svg&gt;</code>元素的宽高一样。</p>
</li>
<li><p>preserveAspectRatio：<br>当视窗的宽高比和用户坐标宽高比不同时就会使得svg发生形变，而preserveAspectRatio属性就是强制统一缩放比来保持图形的宽高比。<br><code>preserveAspectRatio = defer? &lt;align&gt; &lt;meetOrSlice&gt;?</code><br>– defer声明是可选的，并且只有当你在<image>上添加preserveAspectRatio才被用到。在svg中显然没啥用。<br>– align参数声明是否强制统一放缩，如果是，对齐方法会在viewBox的宽高比不符合viewport的宽高比的情况下生效。<br>  如果align值设为none，图形不再保持宽高比而会缩放来适应视窗。<br>– meetOrSlice也是可选的，默认值为meet。这个属性声明整个viewBox在视窗中是否可见。如果是，它和align参数通过一个或多个空格分隔。<br>&nbsp;<br>####3.SVG—&gt;text标签<br>#####有x,y,dx,dy,rotate,textLength,lengthAdjust  这些属性</image></p>
</li>
<li>x,y表示文本的横纵坐标。  </li>
<li>dx,dy表示移动的横纵坐标。 </li>
<li>rotate表示旋转的度数。</li>
<li>text-anchor：设置文本排列属性 start|middle|end|inherit<br>&nbsp;</li>
</ul>
<p>###二、动画要点：stroke-dasharray和stroke-dashoffset以及CSS3</p>
<p>stroke-dasharray: 虚线的疏密程度</p>
<p>stroke-dashoffset: 偏移</p>
<p>@keyframes stroke {<br>  100% {<br>    stroke-dashoffset: -400; } } </p>
<p>设置好stroke-dasharray，通过改变stroke-dashoffset来实现动画，思路很简单，就看你的想象力了。</p>
<p>六、路径的长度<br>如果想知道路径，或线条的准确长度。可能需要借助JavaScript，类似下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var path = document.querySelector(&apos;path&apos;);</span><br><span class="line">var length = path.getTotalLength();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>svg</category>
      </categories>
      <tags>
        <tag>svg</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title>formatDate函数</title>
    <url>/2017/12/12/Date()%20%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%80%E4%B8%AA%20format%20%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">formatDate(date, fmt) &#123;</span><br><span class="line">	if (/(y+)/.test(fmt)) &#123;</span><br><span class="line">		fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &apos;&apos;).substr(4 - RegExp.$1.length));</span><br><span class="line">	&#125;</span><br><span class="line">	let o = &#123;</span><br><span class="line">		&apos;M+&apos;: date.getMonth() + 1,</span><br><span class="line">		&apos;d+&apos;: date.getDate(),</span><br><span class="line">		&apos;h+&apos;: date.getHours(),</span><br><span class="line">		&apos;m+&apos;: date.getMinutes(),</span><br><span class="line">		&apos;s+&apos;: date.getSeconds()</span><br><span class="line">	&#125;;</span><br><span class="line">	for (let k in o) &#123;</span><br><span class="line">		if (new RegExp(`($&#123;k&#125;)`).test(fmt)) &#123;</span><br><span class="line">			let str = o[k] + &apos;&apos;;</span><br><span class="line">			fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return fmt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> padLeftZero(str) &#123;</span><br><span class="line">	return (&apos;00&apos; + str).substr(str.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2018/08/10/ES6/</url>
    <content><![CDATA[<h3 id="一、-变量赋值与解构"><a href="#一、-变量赋值与解构" class="headerlink" title="一、 变量赋值与解构"></a>一、 变量赋值与解构</h3><ol>
<li><p>默认值赋值注意点：</p>
<ul>
<li><p>只有当一个数组成员严格等于undefined，默认值才会生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line">let [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line">let [x = y, y = 1] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><br></p>
<a id="more"></a>
<ol start="2">
<li><p>变量的解构注意点：</p>
<ul>
<li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line">let &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; prop: x &#125; = undefined; // TypeError</span><br><span class="line">let &#123; prop: y &#125; = null; // TypeError</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了区分模式，还是表达式 –&gt; 只要有可能导致解构的歧义，就不得使用圆括号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//变量申明</span><br><span class="line">let [(a)] = [1];</span><br><span class="line">let &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 函数参数</span><br><span class="line">function f([(z)]) &#123; return z; &#125;</span><br><span class="line">function f([z,(x)]) &#123; return x; &#125;</span><br><span class="line"></span><br><span class="line">//赋值语句的模式部分</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br><span class="line"></span><br><span class="line">//可以使用（赋值语句的非模式部分）</span><br><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>&gt; 与`for...of`配合 获取键名和键值就非常方便。
</code></pre><p><br>  </p>
<h3 id="二、-字符串拓展"><a href="#二、-字符串拓展" class="headerlink" title="二、- 字符串拓展"></a>二、- 字符串拓展</h3><ol>
<li>详见<a href="http://es6.ruanyifeng.com/#docs/string" target="_blank" rel="noopener">阮一峰老师网站-String</a> </li>
</ol>
<p><br><br></p>
<h3 id="三、-正则拓展"><a href="#三、-正则拓展" class="headerlink" title="三、- 正则拓展"></a>三、- 正则拓展</h3><ol>
<li><p>详见<a href="http://es6.ruanyifeng.com/#docs/regex" target="_blank" rel="noopener">阮一峰老师网站-RegExp</a></p>
<ul>
<li>u修饰符，含义为“Unicode 模式”</li>
<li>y 修饰符“粘连”（sticky）修饰符：确保匹配必须从剩余的第一个位置开始</li>
<li><p>‘后行断言’</p>
<ul>
<li>先行断言：<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code><br>比如：只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code></li>
<li><p>先行否定断言：<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code></p>
</li>
<li><p>后行断言：<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code><br>如：只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code></p>
</li>
<li>后行否定断言：<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code><blockquote>
<p>后行断言与正常情况顺序是相反的，为“先右后左”的执行顺序</p>
</blockquote>
</li>
</ul>
</li>
<li><p>具名组匹配：允许为每一个组匹配指定一个名字；<br>引用某个“具名组匹配” <code>\k&lt;组名&gt;</code>或者<code>\1</code><br>具名组匹配在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（<code>?&lt;year&gt;</code>），然后就可以在exec方法返回结果的groups属性上引用该组名。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const REG = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/;</span><br><span class="line">REG.test(&apos;abc!abc!abc&apos;) // true</span><br><span class="line">REG.test(&apos;abc!abc!ab&apos;) // false</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h3 id="四、-数值的拓展"><a href="#四、-数值的拓展" class="headerlink" title="四、- 数值的拓展"></a>四、- 数值的拓展</h3><ol>
<li>二进制和八进制表示法(前缀<code>0b | 0o</code>)</li>
<li>Number.isFinite(), Number.isNaN()</li>
<li>Number.parseInt(), Number.parseFloat()</li>
<li>Number.isInteger()</li>
<li>Number.EPSILON(最小精度) <code>2 ** -52</code> </li>
<li>安全整数和 Number.isSafeInteger()：  判断是否在安全值范围</li>
<li>Math 对象的扩展</li>
<li>指数运算符<code>**</code></li>
</ol>
<p><br><br></p>
<h3 id="五、-函数的扩展"><a href="#五、-函数的扩展" class="headerlink" title="五、- 函数的扩展"></a>五、- 函数的扩展</h3><ol>
<li>函数参数的默认值</li>
<li>rest 参数 …props</li>
<li>严格模式</li>
<li>name 属性</li>
<li><p>箭头函数 =&gt;this引用的外层函数<br>注意点：</p>
<ul>
<li>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>
</li>
<li><p>双冒号运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> foo::bar;</span><br><span class="line"> // 等同于</span><br><span class="line"> bar.bind(foo);</span><br><span class="line"> </span><br><span class="line"> var method = obj::obj.foo;</span><br><span class="line">// 等同于</span><br><span class="line">var method = ::obj.foo;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾调用:(指某个函数的最后一步是调用另一个函数)优化</p>
<ul>
<li>只保留内层调用<blockquote>
<p>注意点：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>尾递归:尾调用自身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</span><br><span class="line"> function factorial(n) &#123;</span><br><span class="line">    if (n === 1) return 1;</span><br><span class="line">    return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br><span class="line"></span><br><span class="line">//尾递归优化，只保留一个调用记录，复杂度 O(1) 。</span><br><span class="line">function factorial(n, total = 1) &#123;</span><br><span class="line">    if (n === 1) return total;</span><br><span class="line">    return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips：把所有用到的内部变量改写成函数的参数</p>
</blockquote>
</li>
</ol>
<p><br><br></p>
<h3 id="六、-数组的扩展"><a href="#六、-数组的扩展" class="headerlink" title="六、- 数组的扩展"></a>六、- 数组的扩展</h3><ol>
<li><p>扩展运算符（<code>...[]</code>）的应用</p>
<ul>
<li>转成参数序列</li>
<li><p>复制数组</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1.concat(); //es5</span><br><span class="line"></span><br><span class="line">const a3 = [...a1];     //es6</span><br><span class="line">const [...a4] = a1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并数组 <code>[...arr1, ...arr2, ...arr3]</code> （浅拷贝）</p>
</li>
<li>解构赋值 <code>const [first, ...rest] = [1, 2, 3, 4, 5]</code></li>
<li><p>正确返回字符长度 <code>[...str].length</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;x\uD83D\uDE80y&apos;.length // 4</span><br><span class="line">[...&apos;x\uD83D\uDE80y&apos;].length // 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 <code>Iterator</code> 接口的对象.<br>任何 <code>Iterator</code> 接口的对象，都可以用扩展运算符转为真正的数组。<br>对于那些没有部署 <code>Iterator</code>接口的类似数组的对象,使用<code>Array.from(arrayLike)</code>，实际上任何有length属性的对象，都可以通过Array.from方法转为数组。</p>
</li>
</ul>
</li>
<li><p><code>Array.from()</code>:</p>
<ul>
<li>用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map）。</li>
<li><p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.from(arrayLike, x =&gt; x * x);</span><br><span class="line">// 等同于</span><br><span class="line">Array.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">Array.from([1, 2, 3], (x) =&gt; x * x)</span><br><span class="line">// [1, 4, 9]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><code>Array.of()</code>:</p>
<ul>
<li>用于将一组值，转换为数组。</li>
<li><p>为了弥补构造函数<code>Array()</code>的不足</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//参数个数不一样行为不同</span><br><span class="line">Array() // []</span><br><span class="line">Array(3) // [, , ,]</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br></pre></td></tr></table></figure>
<p> <code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
</li>
</ul>
</li>
<li><p>数组实例的 <code>copyWithin()</code></p>
<ul>
<li>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。。</li>
<li><code>Array.prototype.copyWithin(target, start = 0, end = this.length)</code></li>
</ul>
</li>
<li><p>数组实例的 <code>fill()</code> </p>
<ul>
<li>可用于填充数组，数组中已有的元素，会被全部抹去。</li>
<li><p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;].fill(7, 1, 3)</span><br><span class="line">// [&apos;a&apos;, 7, 7, &apos;d&apos;]</span><br><span class="line"></span><br><span class="line">//&gt; 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</span><br><span class="line">let arr = new Array(3).fill([]);</span><br><span class="line">arr[0].push(5);</span><br><span class="line">// arr = [[5], [5], [5]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>数组实例的 <code>entries()</code>，<code>keys()</code> 和 <code>values()</code>   </p>
<ul>
<li><p>用<code>for...of</code>循环进行遍历，keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">    console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;1</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数组实例的 <code>includes()</code></p>
<ul>
<li><p>表示某个数组是否包含给定的值(第二个参数表示搜索的起始位置)，与字符串的includes方法类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3].includes(3, 3)   // false</span><br><span class="line">[1, 2, 3].includes(3, -1)  // true</span><br><span class="line">[1, 2, [3]].includes([3])  // false</span><br><span class="line">[NaN].includes(NaN)        // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数组实例的 <code>flat()</code>，<code>flatMap()</code> —Chrome无此方法(2018/8/21)</p>
<ul>
<li><p><code>flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。参数：想要拉平的层数，默认为1。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [1, 2, [3, [4, 5]]].flat()</span><br><span class="line"> // [1, 2, 3, [4, 5]]</span><br><span class="line"> </span><br><span class="line"> //如果原数组有空位，flat()方法会跳过空位。</span><br><span class="line">[1, 2, , 4, 5].flat()</span><br><span class="line"> // [1, 2, 4, 5]</span><br><span class="line"> </span><br><span class="line"> [1, [2, [3]]].flat(Infinity) //Infinity:不管有多少层嵌套，都要转成一维数组</span><br><span class="line"> // [1, 2, 3]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flatMap()</code> 方法对原数组的每个成员执行一个函数,然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。传入函数（类似<code>map</code>）,只能展开一层</p>
</li>
</ul>
</li>
<li><p>数组的空位的处理</p>
<ul>
<li><p>ES5：</p>
<ul>
<li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li>
</ul>
</li>
<li><p>ES6：</p>
<ul>
<li><p>明确将空位转为undefined</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[...[&apos;a&apos;,,&apos;b&apos;]]</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h3 id="七、-对象的扩展"><a href="#七、-对象的扩展" class="headerlink" title="七、- 对象的扩展"></a>七、- 对象的扩展</h3><ol>
<li>简写<code>{foo} === {foo: foo}</code></li>
<li><p><code>Object.is()</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://es6.ruanyifeng.com/#docs/object" target="_blank" rel="noopener">对象详情</a></p>
</li>
</ol>
<p><br><br></p>
<h3 id="八、Symbol类型：表示独一无二的值"><a href="#八、Symbol类型：表示独一无二的值" class="headerlink" title="八、Symbol类型：表示独一无二的值"></a>八、Symbol类型：表示独一无二的值</h3><ol>
<li>Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</li>
<li>Symbol 值不能与其他类型的值进行运算，会报错。</li>
<li>Symbol 值可以显式转为字符串|布尔值但不能转为数值。</li>
<li>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</li>
</ol>
<p><br><br></p>
<h3 id="九、-Set-和-Map-数据结构"><a href="#九、-Set-和-Map-数据结构" class="headerlink" title="九、 Set 和 Map 数据结构"></a>九、 Set 和 Map 数据结构</h3><ol>
<li><p>Set: 它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const set = new Set([1, 2, 3, 4, 4, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br><span class="line"></span><br><span class="line">//在 Set 内部，两个NaN是相等。</span><br><span class="line">//另外，两个对象总是不相等的。</span><br></pre></td></tr></table></figure>
<ul>
<li>add(value)：添加某个值，返回 Set 结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
</li>
<li><p>WeakSet :与 Set 类似,但 <code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值。<br>没有size属性，没有办法遍历它的成员。</p>
</li>
<li><p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line">const k1 = [&apos;a&apos;];</span><br><span class="line">const k2 = [&apos;a&apos;];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, 111)</span><br><span class="line">.set(k2, 222);</span><br><span class="line"></span><br><span class="line">map.get(k1) // 111</span><br><span class="line">map.get(k2) // 222</span><br></pre></td></tr></table></figure>
</li>
<li><p>WeakMap :与Map结构类似，也是用于生成键值对的集合。</p>
<ul>
<li><p>区别：</p>
<ul>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li><p>WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const wm = new WeakMap();</span><br><span class="line"></span><br><span class="line">const element = document.getElementById(&apos;example&apos;);</span><br><span class="line"></span><br><span class="line">wm.set(element, &apos;some information&apos;);</span><br><span class="line">wm.get(element) // &quot;some information&quot;</span><br><span class="line">/*</span><br><span class="line">先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，</span><br><span class="line">并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element</span><br><span class="line">的引用就是弱引用，不会被计入垃圾回收机制即DOM节点对象的引用计数是1，而不是2。</span><br><span class="line">可以有效防止内存泄漏。</span><br><span class="line">（WeakMap 的另一个用处是部署私有属性。如果删除实例，它们也就随之消失）</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h3 id="十、-Proxy"><a href="#十、-Proxy" class="headerlink" title="十、 Proxy"></a>十、 Proxy</h3><ol>
<li><p>含义：在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。（代理器）</p>
</li>
<li><p><code>new Proxy(target, handler)</code></p>
</li>
<li><p>Proxy支持的拦截操作</p>
<ol>
<li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ol>
</li>
</ol>
<p><br><br></p>
<h3 id="十一、-Reflect"><a href="#十一、-Reflect" class="headerlink" title="十一、 Reflect"></a>十一、 Reflect</h3><ol>
<li>从Reflect对象上可以拿到语言内部的方法。</li>
<li><p>13个静态方法</p>
<ul>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li><p>Reflect.get(target, name, receiver)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myObject = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: 2,</span><br><span class="line">  get baz() &#123;</span><br><span class="line">    return this.foo + this.bar;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">console.log(Reflect.get(myObject, &apos;foo&apos;)) // 1</span><br><span class="line">console.log(Reflect.get(myObject, &apos;bar&apos;)) // 2</span><br><span class="line">console.log(Reflect.get(myObject, &apos;baz&apos;)) // 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>- Reflect.set(target, name, value, receiver)

    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myObject.foo // 1</span><br><span class="line"></span><br><span class="line">Reflect.set(myObject, &apos;foo&apos;, 2);</span><br><span class="line">myObject.foo // 2</span><br></pre></td></tr></table></figure>


- Reflect.defineProperty(target, name, desc)

    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 新写法</span><br><span class="line">Reflect.defineProperty(MyDate, &apos;now&apos;, &#123;</span><br><span class="line">  value: new Date()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(MyDate.now)</span><br></pre></td></tr></table></figure>


- Reflect.deleteProperty(target, name)
- Reflect.has(target, name)
- Reflect.ownKeys(target)
- Reflect.isExtensible(target)
- Reflect.preventExtensions(target)
- Reflect.getOwnPropertyDescriptor(target, name)

    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myObject = &#123;&#125;;</span><br><span class="line">Reflect.defineProperty(myObject, &apos;hidden&apos;, &#123;</span><br><span class="line">  value: true,</span><br><span class="line">  writable:true,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const theDescriptor = Reflect.getOwnPropertyDescriptor(myObject,&apos;hidden&apos;);</span><br><span class="line">console.log(theDescriptor)</span><br><span class="line">//&#123;value: true, writable: true, enumerable: false, configurable: false&#125;</span><br><span class="line">myObject.hidden = 1</span><br><span class="line">console.log(myObject) //&#123;hidden: 1&#125;</span><br></pre></td></tr></table></figure>


- Reflect.getPrototypeOf(target)
- Reflect.setPrototypeOf(target, prototype)
</code></pre><ol start="3">
<li><p>实例：使用 Proxy 实现观察者模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const queuedObservers = new Set();</span><br><span class="line"></span><br><span class="line">const observe = fn =&gt; queuedObservers.add(fn);</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);</span><br><span class="line"></span><br><span class="line">function set(target, key, value, receiver) &#123;</span><br><span class="line">  const result = Reflect.set(target, key, value, receiver);</span><br><span class="line">  queuedObservers.forEach(observer =&gt; observer());</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person = observable(&#123;</span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">function print() &#123;</span><br><span class="line">  console.log(`$&#123;person.name&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">person.name = &apos;李四&apos;;  //李四</span><br><span class="line">person.name = &apos;33&apos;;     //33</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者—这跟vue很相似</p>
</blockquote>
</li>
</ol>
<p><br><br></p>
<h3 id="十二、-Promise-对象"><a href="#十二、-Promise-对象" class="headerlink" title="十二、 Promise 对象"></a>十二、 Promise 对象</h3><ol>
<li><p>含义：Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
</li>
<li><p><code>Promise.prototype.then()</code>：<br>then方法返回的是一个新的Promise实例。因此可以采用链式写法</p>
</li>
<li><p><code>Promise.prototype.catch()</code>：<br><code>.then(null, rejection)</code>的别名,一般建议总是使用<code>catch</code>方法。<code>catch</code>方法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。</p>
<blockquote>
<p>如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码</p>
</blockquote>
</li>
<li><p><code>Promise.prototype.finally()</code>：<br>不管 Promise 对象最后状态如何，都会执行的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  // 语句</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">    return result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    //...</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p><code>Promise.all()</code>：<br><code>const p = Promise.all([p1, p2, p3]);</code></p>
<blockquote>
<p>注意：</p>
<ul>
<li>（<code>Promise.all</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</li>
<li>只有所有的状态都变成<code>fulfilled</code>，返回值组成一个数组，传递给回调函数，<br>或者有一个变为<code>rejected</code>，被<code>reject</code>的实例的返回值才会继续传递给回调函数。</li>
</ul>
</blockquote>
</li>
<li><p><code>Promise.race()</code>：<br><code>const p = Promise.race([p1, p2, p3]);</code><br>只要有一个状态改变就。。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//当接口五秒内未返回就报超时错误</span><br><span class="line">const p = Promise.race([</span><br><span class="line">  fetch(&apos;/resource-that-may-take-a-while&apos;),</span><br><span class="line">  new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(console.log)</span><br><span class="line">.catch(console.error);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li><p><code>Promise.resolve()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&apos;foo&apos;)</span><br><span class="line">// 等价于（可以将现有对象转成Promise对象）</span><br><span class="line">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</span><br></pre></td></tr></table></figure>
<ul>
<li>参数是个Promise 实例：不做修改直接返回这个实例</li>
<li>参数是个具有then方法的对象：先转Promise然后立即执行then方法</li>
<li>参数不是具有then方法的对象，或根本就不是对象：返回状态为resolved的Promise对象<br>不带有任何参数：直接返回一个resolved状态的 Promise 对象。</li>
</ul>
</li>
<li><p><code>Promise.reject()</code>：<br>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p>
</li>
<li><p><code>Promise.try()</code>：<br>不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它时。</p>
<blockquote>
<p>解决方案1 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const f = () =&gt; console.log(&apos;now&apos;);</span><br><span class="line">(async () =&gt; f())()</span><br><span class="line">console.log(&apos;next&apos;)</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>解决方案2 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const f = () =&gt; console.log(&apos;now&apos;);</span><br><span class="line">(</span><br><span class="line">  () =&gt; new Promise(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line">console.log(&apos;next&apos;);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p><br><br><br></p>
<h3 id="十三、Iterator-和-for…of-循环"><a href="#十三、Iterator-和-for…of-循环" class="headerlink" title="十三、Iterator 和 for…of 循环"></a>十三、Iterator 和 for…of 循环</h3><h4 id="①-Iterator"><a href="#①-Iterator" class="headerlink" title="①. Iterator"></a>①. Iterator</h4><ol>
<li><p>凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。<br>原生具备<code>Iterator</code>接口的数据结构 (可以用for…of遍历它们）：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象<br><br></li>
</ul>
</li>
<li><p>默认调用<code>Symbol.iterator</code>方法的情况</p>
<ul>
<li>对数组和 Set 结构进行解构赋值时</li>
<li>使用扩展运算符（…）</li>
<li><p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const generator = function* () &#123;</span><br><span class="line">  yield* [1,2];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() // &#123; value: 1, done: false &#125;</span><br><span class="line">iterator.next() // &#123; value: 2, done: false &#125;</span><br><span class="line">iterator.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的遍历会调用遍历器接口</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li>
<li>Promise.all()</li>
<li>Promise.race()<br>…….</li>
</ul>
</li>
</ul>
</li>
<li>字符串是一个类似数组的对象，也原生具有 Iterator 接口。 </li>
<li><p>遍历器对象的 return()</p>
<blockquote>
<p>可以触发return的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 情况一:break</span><br><span class="line">for (let line of readLinesSync(fileName)) &#123;</span><br><span class="line">  console.log(line);</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二:Error</span><br><span class="line">for (let line of readLinesSync(fileName)) &#123;</span><br><span class="line">  console.log(line);</span><br><span class="line">  throw new Error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<ul>
<li>情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；</li>
<li>情况二会在执行return方法关闭文件之后，再抛出错误。</li>
</ul>
</li>
</ol>
<p><br></p>
<h4 id="②-for…of-循环"><a href="#②-for…of-循环" class="headerlink" title="②. for…of 循环"></a>②. for…of 循环</h4><ol>
<li><code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</li>
<li><code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。<br><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [3, 5, 7];</span><br><span class="line">arr.foo = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (let i in arr) &#123;</span><br><span class="line">  console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i of arr) &#123;</span><br><span class="line">  console.log(i); //  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h4><ol>
<li>Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组(<code>[k,v]</code>)</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li>对于没有Iterator接口的类数组对象：使用<code>Array.from</code>方法将其转为数组。</li>
</ol>
<p><br><br></p>
<h3 id="十四、Generator-函数的语法"><a href="#十四、Generator-函数的语法" class="headerlink" title="十四、Generator 函数的语法"></a>十四、Generator 函数的语法</h3><ol>
<li><p>Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myIterable = &#123;&#125;</span><br><span class="line">myIterable[Symbol.iterator] = function* () &#123;</span><br><span class="line">  yield 1</span><br><span class="line">  yield 2</span><br><span class="line">  yield 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log([...myIterable])  // [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p><br></p>
</li>
<li>注意：<ul>
<li><code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</li>
<li><code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</li>
<li><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。<br><br><br></li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><code>next</code> 方法的参数</p>
<ul>
<li><code>next</code>方法可以带一个参数，该参数就会被当作<strong>上一个<code>yield</code>表达式的返回值</strong>。<br>也就是说：可以在 <code>Generator</code>函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。<ul>
<li>注意: 由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的<br><br></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Generator.prototype.throw()</code>:</p>
<ul>
<li>只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</li>
<li>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。<br><br>   </li>
</ul>
</li>
<li><p><code>Generator.prototype.return()</code>:</p>
<ul>
<li>可以返回给定的值，并且终结遍历 Generator 函数。<br><br></li>
</ul>
</li>
<li><p><code>yield*</code> 表达式：为了说明<code>yield</code>表达式后面跟的是一个遍历器对象时加<code>*</code><br><br></p>
</li>
<li><p><code>Generator</code> 函数的<code>this</code>:</p>
<ul>
<li>Generator 函数总是返回遍历器对象而不是<code>this</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">  this.a = 1;</span><br><span class="line">  yield this.b = 2;</span><br><span class="line">  yield this.c = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function F() &#123;</span><br><span class="line">  return gen.call(gen.prototype);//&lt;--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = new F();</span><br><span class="line"></span><br><span class="line">f.next();  // Object &#123;value: 2, done: false&#125;</span><br><span class="line">f.next();  // Object &#123;value: 3, done: false&#125;</span><br><span class="line">f.next();  // Object &#123;value: undefined, done: true&#125;</span><br><span class="line"></span><br><span class="line">f.a // 1</span><br><span class="line">f.b // 2</span><br><span class="line">f.c // 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
</li>
<li><p><code>Generator</code> </p>
<ul>
<li>与状态机:完美管理状态</li>
<li>协程：既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</li>
<li>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。</li>
<li>与普通线程差异：<ul>
<li>同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。</li>
<li>普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。              </li>
</ul>
</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h3 id="十五、Generator-函数的异步应用"><a href="#十五、Generator-函数的异步应用" class="headerlink" title="十五、Generator 函数的异步应用"></a>十五、Generator 函数的异步应用</h3><ol>
<li><p>传统方法 </p>
<ul>
<li><p>回调函数 -&gt;（callback hell）强耦合</p>
</li>
<li><p>事件监听</p>
</li>
<li><p>发布/订阅</p>
</li>
<li><p><code>Promise</code>对象 -&gt;代码冗余，原来的任务被<code>Promise</code>包装了一下，一堆then，原来的语义变得很不清楚。<br><br></p>
</li>
</ul>
</li>
<li><p><code>Thunk</code> 函数:是“传名调用”的一种实现策略，用来替换某个表达式。<br> /JavaScript 语言是传值调用,以下是个自执行器（thunkify、co模块、)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   //实现自执行</span><br><span class="line">  function thunkify(fn) &#123;</span><br><span class="line">     return function() &#123;</span><br><span class="line">       var args = new Array(arguments.length);</span><br><span class="line">       var ctx = this;</span><br><span class="line">   		</span><br><span class="line">       for (var i = 0; i &lt; args.length; ++i) &#123;</span><br><span class="line">         args[i] = arguments[i];</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       return function (done) &#123;</span><br><span class="line">         var called;</span><br><span class="line">         args.push(function () &#123;</span><br><span class="line">           if (called) return;</span><br><span class="line">           called = true;</span><br><span class="line">           done.apply(null, arguments);</span><br><span class="line">         &#125;);</span><br><span class="line">   </span><br><span class="line">         try &#123;</span><br><span class="line">           fn.apply(ctx, args);</span><br><span class="line">         &#125; catch (err) &#123;</span><br><span class="line">           done(err);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">      </span><br><span class="line">    const ft = (n,cb) =&gt;cb(n)</span><br><span class="line">    const CB = thunkify(ft)  </span><br><span class="line">       </span><br><span class="line">       //实现自执行</span><br><span class="line">       function run(fn) &#123;</span><br><span class="line">         var gen = fn()</span><br><span class="line">       </span><br><span class="line">         function next(err, data) &#123;</span><br><span class="line">           var result = gen.next(data)</span><br><span class="line">           console.log(result)</span><br><span class="line">           if (result.done) return;</span><br><span class="line">           result.value(next)</span><br><span class="line">         &#125;</span><br><span class="line">       </span><br><span class="line">         next()</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   </span><br><span class="line">       const g = function* ()&#123;</span><br><span class="line">         var f1 = yield CB(&apos;aaaaaa&apos;)</span><br><span class="line">         var f2 = yield CB(&apos;bbbbbb&apos;)</span><br><span class="line">         // ...</span><br><span class="line">         var fn = yield CB(&apos;nnnnnn&apos;)</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       run(g)</span><br><span class="line">   ```     </span><br><span class="line">   &lt;br/&gt;</span><br><span class="line">  </span><br><span class="line">3. CO模块</span><br><span class="line">   1. 原理：Generator 就是一个异步操作的容器。它的自动执行需要一种机制，**当异步操作有了结果**，能够自动交回执行权。以下两种方法可以做到这一点：</span><br><span class="line">       - 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</span><br><span class="line">       - Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。</span><br><span class="line">       &lt;br&gt;</span><br><span class="line">   2. 基于 Promise 对象的自动执行</span><br></pre></td></tr></table></figure>
<p>function run(gen){<br>  var g = gen();</p>
<p>  function next(data){</p>
<pre><code>var result = g.next(data)
console.log(result)
if (result.done) return result.value
result.value.then(function(data){
  next(data);
});
</code></pre><p>  }</p>
<p>  next();<br>}</p>
<p>//需要返回promise 然后链式自执行<br>const CO = (data) =&gt; new Promise((resolve)=&gt; resolve(data))<br>const g = function* (){<br>  var f1 = yield CO(‘aaaaaa’)<br>  var f2 = yield CO(‘bbbbbb’)<br>  // …<br>  var fn = yield CO(‘nnnnnn’)<br>}</p>
<p>run(g)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    3. 处理并发的异步操作</span><br><span class="line">     - co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</span><br><span class="line">     </span><br><span class="line">    4. 实例：处理 Stream</span><br><span class="line">&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 十六、async 函数</span><br><span class="line"> 1. Generator 函数的语法糖</span><br><span class="line">    - 改进</span><br><span class="line">     - （1）async函数自带执行器。</span><br><span class="line">     - （2）更广的适用性</span><br><span class="line">        `co模块`约定，`yield`命令后面只能是`Thunk`函数或`Promise`对象，而`async`函数的`await`命令后面，可以是`Promise`对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</span><br><span class="line">     - （3）返回值是 `Promise`。</span><br><span class="line">        `Generator` 函数的返回值是 `Iterator` 对象</span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 2. 注意点</span><br><span class="line">    1. async函数内部`return`语句返回的值，会成为`then`方法回调函数的参数。</span><br><span class="line">    2. async函数内部抛出错误，会导致返回的`Promise`对象变为`reject`状态。抛出的错误对象会被`catch`方法回调函数接收到。</span><br><span class="line">    3. 只要一个`await`语句后面的`Promise`变为`reject`，那么整个`async`函数都会中断执行。 =&gt; 想继续执行 可以吧代码放在`try...catch`中。</span><br><span class="line">    4. await命令只能用在async函数之中，如果用在普通函数，就会报错。</span><br><span class="line">     - forEach/Map中使用async也会出问题 :</span><br></pre></td></tr></table></figure>
<p> // scope B<br>array.forEach(async function(item) { // scope A<br>  await wait(1000);<br>});<br>/<em><br><code>Scope B</code> 部分的代码并不会等待 <code>Scope A</code> 中的 <code>async/await</code> 执行完后继续执行后面的代码，相反，他会立刻执行后面的代码
</em>/</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     - 正确的写法是采用for循环、</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"> 3. 并发执行</span><br></pre></td></tr></table></figure>
<p>// 写法一<br>let [foo, bar] = await Promise.all([getFoo(), getBar()]);</p>
<p>// 写法二<br>let fooPromise = getFoo();<br>let barPromise = getBar();<br>let foo = await fooPromise;<br>let bar = await barPromise;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">4. `for await...of`:遍历异步的 Iterator 接口。</span><br></pre></td></tr></table></figure>
<p>for await (const chunk of readStream) {</p>
<pre><code>console.log(&apos;&gt;&gt;&gt; &apos;+chunk);
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"> 5. 异步 Generator 函数</span><br><span class="line">    - 在头部加async 标志，此时即可返回一个Promise</span><br><span class="line"> </span><br><span class="line">&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 十七、Class 的基本语法</span><br><span class="line"> 1. `constructor` 方法</span><br><span class="line">    - 通过new命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。</span><br><span class="line">    - `constructor`方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 2. `class Foo &#123;&#125;`不存在声明提升 </span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 3. 私有方法和私有属性 </span><br><span class="line">    - 函数名加下划线（仅为命名方法，外部仍可调用） </span><br><span class="line">    - 将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</span><br></pre></td></tr></table></figure>
<p>class Widget {<br>  foo (baz) {</p>
<pre><code>bar.call(this, baz);
</code></pre><p>  }<br>  // …<br>}</p>
<p>function bar(baz) {<br>  return this.snaf = baz;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 利用`Symbol`值的唯一性，将私有方法的名字命名为一个Symbol值。</span><br></pre></td></tr></table></figure>
<p>const bar = Symbol(‘bar’)<br>const snaf = Symbol(‘snaf’)</p>
<p>export default class myClass{<br>  foo(baz) {</p>
<pre><code>this[bar](baz);
</code></pre><p>  }</p>
<p>  // 私有方法<br>  <a href="baz">bar</a> {</p>
<pre><code>return this[snaf] = baz;
</code></pre><p>  }<br>  // …<br>};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;br/&gt;</span><br><span class="line">4. this 的指向</span><br><span class="line">   - 当类的方法中有this使用且方法被提取出来单独使用时this会指向方法运行环境导致意料之外的错误</span><br><span class="line">   1. 可以在构造函数中绑定`this.printName = this.printName.bind(this)`</span><br><span class="line">   2. 箭头函数：</span><br></pre></td></tr></table></figure>
<p>constructor() {</p>
<pre><code>this.printName = (name = &apos;there&apos;) =&gt; {
  this.print(`Hello ${name}`)
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 使用Proxy，获取方法的时候，自动绑定this</span><br></pre></td></tr></table></figure>
<p>function selfish (target) {<br>  const cache = new WeakMap();<br>  const handler = {</p>
<pre><code>get (target, key) {
  const value = Reflect.get(target, key);
  if (typeof value !== &apos;function&apos;) {
    return value;
  }
  if (!cache.has(value)) {
    cache.set(value, value.bind(target));
  }
  return cache.get(value);
}
</code></pre><p>  };<br>  const proxy = new Proxy(target, handler);<br>  return proxy;<br>}</p>
<p>const logger = selfish(new Logger());</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;br/&gt;</span><br><span class="line">- Class 的取值函数（getter）和存值函数（setter）</span><br></pre></td></tr></table></figure>
<p>class MyClass {<br>  constructor() {</p>
<pre><code>// ...
</code></pre><p>  }<br>  get prop() {</p>
<pre><code>return &apos;getter&apos;;
</code></pre><p>  }<br>  set prop(value) {</p>
<pre><code>console.log(&apos;setter: &apos;+value);
</code></pre><p>  }<br>}</p>
<p>let inst = new MyClass();</p>
<p>inst.prop = 123;<br>// setter: 123</p>
<p>inst.prop<br>// ‘getter’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    &lt;/br&gt;</span><br><span class="line">    - Class 的静态方法</span><br><span class="line">        在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用</span><br><span class="line">  &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 十八、Class 的继承</span><br><span class="line"> 1. 子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用`super`方法，子类就得不到`this`对象。 =&gt;`constructor`不写默认 有`super(...args)`</span><br><span class="line"> </span><br><span class="line"> 2. `Object.getPrototypeOf`：从子类上获取父类</span><br></pre></td></tr></table></figure>
<p>//可以使用这个方法判断，一个类是否继承了另一个类。<br>Object.getPrototypeOf(ColorPoint) === Point<br>// true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">3. `super`:</span><br><span class="line">   - super在B的构造函数中，指向`A.prototype`，所以`super`可以拿到父类原型对象上的实例方法</span><br><span class="line">   - 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</span><br><span class="line"></span><br><span class="line">4. 原生构造函数的继承</span><br><span class="line">   - Boolean()</span><br><span class="line">   Number()</span><br><span class="line">   String()</span><br><span class="line">   Array()</span><br><span class="line">   Date()</span><br><span class="line">   Function()</span><br><span class="line">   RegExp()</span><br><span class="line">   Error()</span><br><span class="line">   Object()</span><br><span class="line">   &gt;原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</span><br><span class="line">   &gt;`extends`关键字不仅可以用来继承类，还可以用来继承原生的构造函数!</span><br><span class="line"></span><br><span class="line">5. Mixin 模式的实现(多个对象合成一个新的对象)</span><br></pre></td></tr></table></figure>
<p>function mix(…mixins) {<br>  class Mix {}</p>
<p>  for (let mixin of mixins) {</p>
<pre><code>copyProperties(Mix.prototype, mixin); // 拷贝实例属性
copyProperties(Mix.prototype, Reflect.getPrototypeOf(mixin)); // 拷贝原型属性
</code></pre><p>  }</p>
<p>  return Mix;<br>}</p>
<p>function copyProperties(target, source) {<br>  for (let key of Reflect.ownKeys(source)) {</p>
<pre><code>if ( key !== &quot;constructor&quot;
  &amp;&amp; key !== &quot;prototype&quot;
  &amp;&amp; key !== &quot;name&quot;
) {
  let desc = Object.getOwnPropertyDescriptor(source, key);
  Object.defineProperty(target, key, desc);
}
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 十九、修饰器（提案）</span><br><span class="line"> 1. 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升</span><br><span class="line"> 2. 详见&gt;&gt;[ES6-修饰器][4]</span><br><span class="line"></span><br><span class="line"> &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 二十、Module 的语法</span><br><span class="line"> 1. 注意点</span><br><span class="line">    - import在静态解析阶段执行，所以它是一个模块之中最早执行的。</span><br><span class="line">    - import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</span><br></pre></td></tr></table></figure>
<p>// 报错<br>import { ‘f’ + ‘oo’ } from ‘my_module’;</p>
<p>// 报错<br>let module = ‘my_module’;<br>import { foo } from module;</p>
<p>// 报错<br>if (x === 1) {<br>  import { foo } from ‘module1’;<br>} else {<br>  import { foo } from ‘module2’;<br>}<br>//在静态分析阶段，这些语法都是没法得到值的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. `export default`命令其实只是输出一个叫做default的变量</span><br><span class="line">3. export 与 import 的复合写法</span><br></pre></td></tr></table></figure>
<p>//foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口<br>export { foo, bar } from ‘my_module’<br>//&gt;可以用来合并一些模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 4. 提案：import()函数 =&gt; 用来动态加载模块 返回Promise</span><br><span class="line"></span><br><span class="line"> &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 二十、Module 的加载实现</span><br><span class="line"> 1. 浏览器加载</span><br><span class="line">    - 传统方法</span><br><span class="line">     -  defer :&quot;渲染完再执行&quot; , 多个defer脚本,会按照它们在页面出现的顺序加载。</span><br><span class="line">     -  async :&quot;下载完就执行&quot; , 多个async脚本,不能保证加载顺序。</span><br><span class="line">    - 加载 ES6 模块</span><br><span class="line">     - `&lt;script type=&quot;module&quot; src=&quot;./...js&quot;&gt;&lt;/script&gt;`:此时行为与defer相同</span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 2. ES6 模块与 CommonJS 模块的差异</span><br><span class="line">     - CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</span><br><span class="line">     - CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 3. Node 加载</span><br><span class="line">    - Node 有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    - Node 要求 ES6 模块采用.mjs后缀文件名。(新版)</span><br></pre></td></tr></table></figure>
<p>$ node –experimental-modules my-app.mjs<br><code>`</code></p>
<ul>
<li>内部变量差异<ul>
<li>ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块。</li>
<li>ES6不存在这些顶层变量：<ol>
<li>arguments</li>
<li>require</li>
<li>module</li>
<li>exports</li>
<li>__filename</li>
<li>__dirname<br><br>  </li>
</ol>
</li>
</ul>
</li>
<li>ES6 模块加载 CommonJS 模块<ul>
<li>Node 的import命令加载 CommonJS 模块，Node 会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>{ default: module.exports }</code></li>
<li>import命令加载 CommonJS 模块时，不允许采用解构的写法，改为整体输入<br><br>  </li>
</ul>
</li>
<li>CommonJS 模块加载 ES6 模块<ul>
<li>不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</li>
</ul>
</li>
</ul>
<p><br></p>
</li>
<li>循环加载<ul>
<li>CommonJS 模块加载原理<ul>
<li>require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</li>
<li>CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li>
<li>由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。<br><br></li>
</ul>
</li>
<li>ES6 模块的循环加载<ul>
<li>与CommonJS不同：变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</li>
<li>a 引用 b,b中引用a,执行到b中对a引用时会认为a已经存在，继续往下执行</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>node fs系统</title>
    <url>/2018/11/16/node%20fs%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p> 引入fs模块 <code>const fs = require(&quot;fs&quot;)</code></p>
<h2 id="1-fs-access-检测-path-指定的文件或目录的用户权限"><a href="#1-fs-access-检测-path-指定的文件或目录的用户权限" class="headerlink" title="1. fs.access  检测 path 指定的文件或目录的用户权限"></a>1. fs.access  检测 path 指定的文件或目录的用户权限</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- path</span></span><br><span class="line"><span class="comment">//- mode 默认fs.constants.F_OK / ~R_OK / ~W_OK</span></span><br><span class="line"><span class="comment">// (文件存在？/可读？/可写？) </span></span><br><span class="line">fs.stat(path, <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"文件："</span> + stats.isFile())</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"目录："</span> + stats.isDirectory())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2-fs-mkdir-创建目录"><a href="#2-fs-mkdir-创建目录" class="headerlink" title="2. fs.mkdir  创建目录"></a>2. fs.mkdir  创建目录</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收参数：</span></span><br><span class="line"><span class="comment">//path            将创建的目录路径</span></span><br><span class="line"><span class="comment">//options &lt;Object&gt; | &lt;integer&gt;</span></span><br><span class="line"><span class="comment">//   recursive &lt;boolean&gt; 默认为 false。是否创建父目录</span></span><br><span class="line"><span class="comment">//   mode &lt;integer&gt; 不支持 Windows 平台。默认为 0o777</span></span><br><span class="line"><span class="comment">//callback      回调，传递异常参数err</span></span><br><span class="line"></span><br><span class="line">fs.mkdir(fileNmae, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"创建目录成功"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="3-fs-writeFile-创建写入文件"><a href="#3-fs-writeFile-创建写入文件" class="headerlink" title="3. fs.writeFile  创建写入文件"></a>3. fs.writeFile  创建写入文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//filename      (String)            文件名称</span></span><br><span class="line"><span class="comment">//data        (String | Buffer)    将要写入的内容，可以使字符串 或 buffer数据。</span></span><br><span class="line"><span class="comment">//options        (Object)           option数组对象，包含：</span></span><br><span class="line"><span class="comment">//· encoding   (string)            可选值，默认 ‘utf8′，当data使buffer时，该值应该为 ignored。</span></span><br><span class="line"><span class="comment">//· mode         (Number)        文件读写权限，默认值 438</span></span><br><span class="line"><span class="comment">//· flag            (String)            默认值 ‘w'</span></span><br><span class="line"><span class="comment">//callback &#123;Function&#125;  回调，传递一个异常参数err。</span></span><br><span class="line"></span><br><span class="line">fs.writeFile(path, <span class="string">"覆盖原内容"</span>, <span class="string">"utf8"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"写入成功"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="4-fs-appendFile-追加文件"><a href="#4-fs-appendFile-追加文件" class="headerlink" title="4. fs.appendFile 追加文件"></a>4. fs.appendFile 追加文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.appendFile(path, <span class="string">"这是写入的内容"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"写入成功"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="5-fs-readFile-读取文件默认Buffer"><a href="#5-fs-readFile-读取文件默认Buffer" class="headerlink" title="5.fs.readFile 读取文件默认Buffer"></a>5.fs.readFile 读取文件默认Buffer</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(path, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// console.log(data.toString())</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="6-fs-readdir读取目录-把目录下面的文件和文件夹都获取到。"><a href="#6-fs-readdir读取目录-把目录下面的文件和文件夹都获取到。" class="headerlink" title="6.fs.readdir读取目录  把目录下面的文件和文件夹都获取到。"></a>6.fs.readdir读取目录  把目录下面的文件和文件夹都获取到。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readdir(dirPath, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"array:"</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="7-fs-rename-重命名"><a href="#7-fs-rename-重命名" class="headerlink" title="7.fs.rename 重命名"></a>7.fs.rename 重命名</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.改名  2.剪切文件(路径不同时)</span></span><br><span class="line"></span><br><span class="line">fs.rename(oldPath, newPath, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"修改名字成功"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="8-fs-rmdir-删除目录"><a href="#8-fs-rmdir-删除目录" class="headerlink" title="8. fs.rmdir  删除目录"></a>8. fs.rmdir  删除目录</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.rmdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"删除目录成功"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="9-fs-unlink删除文件"><a href="#9-fs-unlink删除文件" class="headerlink" title="9. fs.unlink删除文件"></a>9. fs.unlink删除文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.unlink(path, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"删除文件成功"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="10-文件流读写"><a href="#10-文件流读写" class="headerlink" title="10.文件流读写"></a>10.文件流读写</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单读写</span></span><br><span class="line"><span class="keyword">const</span> readerStream = fs.createReadStream(originPath)</span><br><span class="line"><span class="keyword">const</span> writerStream = fs.createWriteStream(tagetPath)</span><br><span class="line">readerStream.pipe(writerStream)</span><br></pre></td></tr></table></figure>
<p>想你~</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>fs</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结</title>
    <url>/2018/09/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="React相关"><a href="#React相关" class="headerlink" title="React相关"></a>React相关</h3><ol>
<li>React中的props和state的用法：<ul>
<li>props:(只读性)<ul>
<li>单项数据流且不可改变</li>
<li>只有通过父组件重新渲染的方式才可以把新的props传入组件中。</li>
</ul>
</li>
<li>state:(可变)<ul>
<li>组件内部数据状态</li>
<li>需要通过this.setState()方法来修改state。</li>
<li>调用this.setState方法时，组件进行重新渲染。</li>
</ul>
</li>
<li><code>setState(updater, callback)</code>：<ul>
<li>(prevState, props) =&gt; stateChange</li>
</ul>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<pre><code>&lt;br/&gt;
</code></pre><ol start="2">
<li>react-router的实现原理 <ul>
<li>有hashStory/browserStory/memoryHistory</li>
<li>browserStory：</li>
<li>简单的说就是由各种<code>forward/back</code>或者<code>&lt;Link to={}/&gt;</code>等会去改变history库的state存入<code>sessionStorage</code>中，history.pushState触发地址栏更新(url),有listen监听地址栏变化后由<code>&lt;Router/&gt;</code>去匹配component -&gt;<code>render</code>出来。</li>
<li><ul>
<li>路由传参 ： =&gt; params(变量匹配路由<code>:id</code>), query(地址栏显示), state(加密)<br><br></li>
</ul>
</li>
</ul>
</li>
<li>React Router 3 -&gt; React Router 4的区别<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
</li>
<li>Redux与VueX<ol>
<li>Redux<ul>
<li>1）redux是一个泛用的状态管理框架</li>
<li>2）解决组件与组件状态管理的问题</li>
<li>3）redux是flux中的一个实现，不是所有的项目都适合redux</li>
<li>4)redux的流程:<ul>
<li>view——&gt;action——&gt;store——&gt;reducer（返回）——&gt;store——view</li>
</ul>
</li>
</ul>
</li>
<li>Vuex<ul>
<li>多个组件调用一个状态，将原来组建与组件之间的状态传递改成组件与仓库之间的传递</li>
<li>state：存放多个组件共享的状态（数据）</li>
<li>mutations：存放更改state里状态的方法，用于变更状态，是唯一一个更改状态的属性</li>
<li>getters：将state中某个状态进行过滤，然后获取新的状态，类似于vue中的computed</li>
<li>actions：用于调用事件动作，并传递给mutation</li>
<li>modules：主要用来拆分state<ul>
<li>Comnent-&gt;(dispatch)Action-&gt;（commit-&gt;Mutations-&gt;（mutate）State-&gt;（render）Component<br><br><br></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="JS相关问题"><a href="#JS相关问题" class="headerlink" title="JS相关问题"></a>JS相关问题</h3><h4 id="1-js的垃圾回收机制：-标记清除、引用计数）"><a href="#1-js的垃圾回收机制：-标记清除、引用计数）" class="headerlink" title="1. js的垃圾回收机制：(标记清除、引用计数）"></a>1. js的垃圾回收机制：(标记清除、引用计数）</h4><ul>
<li>标记清除：当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</li>
<li><p>引用计数：被引用+1 包含对这个值引用的变量又取得了另外一个值-1 状态0为可回收 （无法回收相互引用）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var objA = new Object()</span><br><span class="line">var objB = new Object()</span><br><span class="line"></span><br><span class="line">objA.someOtherObject = objB</span><br><span class="line">objB.anotherObject = objA</span><br></pre></td></tr></table></figure>
<p> <br></p>
</li>
</ul>
<h4 id="2-引起内存泄漏的常见操作"><a href="#2-引起内存泄漏的常见操作" class="headerlink" title="2. 引起内存泄漏的常见操作"></a>2. 引起内存泄漏的常见操作</h4><ul>
<li><p>1) 意外的全局变量引起的内存泄露</p>
</li>
<li><p>2）闭包引起的内存泄露</p>
</li>
<li><p>3）没有清理的DOM元素引用</p>
</li>
<li><p>4）被遗忘的定时器或者回调</p>
</li>
<li><p>5）子元素存在引起的内存泄露</p>
</li>
<li>避免内存泄漏<ul>
<li>1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</li>
<li>2）注意程序逻辑，避免“死循环”之类的 ；</li>
<li>3）避免创建过多的对象  原则：不用了的东西要及时归还。<br><br></li>
</ul>
</li>
</ul>
<h4 id="3-经常遇到的解决js兼容性问题列举至少三个"><a href="#3-经常遇到的解决js兼容性问题列举至少三个" class="headerlink" title="3. 经常遇到的解决js兼容性问题列举至少三个"></a>3. 经常遇到的解决js兼容性问题列举至少三个</h4><ul>
<li>1.设置监听事件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addEvent(obj, type, fn) &#123;</span><br><span class="line">        if (obj.addEventListener) &#123;</span><br><span class="line">            obj.addEventListener(type, fn, false); //非IE</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj.attachEvent(&apos;on&apos; + type, fn); //ie,这里已经加上on，传参的时候注意不要重复加了</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>2.js阻止事件传播，这里使用click事件为例 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.onclick = function(e) &#123;</span><br><span class="line">        var e = e || window.event;</span><br><span class="line">        if (e.stopPropagation) &#123;</span><br><span class="line">            e.stopPropagation(); //W3C标准</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            e.cancelBubble = true; //IE....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>3.js阻止默认事件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.onclick=function(e)&#123;</span><br><span class="line">   var e=e||window.event;</span><br><span class="line">   if (e.preventDefault) &#123;</span><br><span class="line">     e.preventDefault();//W3C标准</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">     e.returnValue=&apos;false&apos;;//IE..</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.鼠标滚轮事件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//火狐中的滚轮事件</span><br><span class="line">document.addEventListener(&quot;DOMMouseScroll&quot;,function(event)&#123;</span><br><span class="line">    alert(event.detail);//若前滚的话为 -3，后滚的话为 3</span><br><span class="line">&#125;,false)</span><br><span class="line">//非火狐中的滚轮事件</span><br><span class="line">document.onmousewheel=function(event)&#123;</span><br><span class="line">    alert(event.detail);//前滚：120，后滚：-120</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>&lt;br/&gt;
</code></pre><h4 id="4-数组方法"><a href="#4-数组方法" class="headerlink" title="4. 数组方法"></a>4. 数组方法</h4><ul>
<li>栈、队列 =&gt; <code>push()</code> 和 <code>pop()</code> / <code>push()</code>和<code>shift()</code> +  <code>unshift()</code>和<code>pop()</code></li>
<li>排序 =》<code>sort()</code> 和 <code>reverse()</code> 两个方法</li>
<li>操作方法 <ul>
<li><ul>
<li><code>concat</code>() 组成新数组 </li>
</ul>
</li>
<li><ul>
<li><code>slice</code>(start ,end) 截取数组但不改变原数组 对应字符串方法 subString() </li>
</ul>
</li>
<li><ul>
<li><code>splice</code>(start, length, another) 数组中最常用的方法 可完成数组删除、插入、替换操作</li>
</ul>
</li>
</ul>
</li>
<li>迭代方法 <ul>
<li><ul>
<li>arr.<code>every</code>(function(item,index,array) 对每一项都返回true才返回true </li>
</ul>
</li>
<li><ul>
<li>arr.<code>some</code>(function(item,index,array) 当某项符合时返回true </li>
</ul>
</li>
<li><ul>
<li><code>hasOwnProperty</code>(propertyName) 检测指定属性是否在当前对象实例中（不包括原型实例） </li>
</ul>
</li>
<li><ul>
<li>arr.<code>filter</code>(function(item,index,array) 返回符合条件的集合 </li>
</ul>
</li>
<li><ul>
<li>arr.<code>forEach</code>(function(item,index,array) 对每一项进行操作 无返回 （无法终止循环除非抛出异常） </li>
</ul>
</li>
<li><ul>
<li>arr.<code>map</code>(function(item,index,array) 返回给定条件的数组</li>
</ul>
</li>
</ul>
</li>
<li>归并方法（<code>reduce</code>/<code>reduceRight</code>）<br><br><h4 id="4-伪数组转数组方法"><a href="#4-伪数组转数组方法" class="headerlink" title="4. 伪数组转数组方法"></a>4. 伪数组转数组方法</h4></li>
<li><code>[].slice.call(arrayLike)</code></li>
<li><code>Array.from(arrayLike)</code></li>
<li>扩展符对有遍历器接口的也可以转成数组<br><br><br>###其他</li>
</ul>
<ol>
<li><p>git 经常用到的命令，至少五个，并且要说出每个命令是干什么的。<br>（git add .）（git commit -m “”）（git push origin **）（git clone）（git branch）（git checkout）</p>
</li>
<li><p>cookie和session的区别</p>
<ul>
<li><p>cookie被意外禁用：</p>
<ul>
<li><p>可以通过url的重写来解决，最简单的方式就是在url的末端加上；注意是分号而不是问号，问号就是请求参数了，然后分号后面加上jsessionid=xxx，这样就相当于模仿cookie发送请求头请求给服务器，这个是最原始的方法，而且实际中也不会这样做，我们可以在用户访问之后通过response对象返回给用户一个url链接，然后在链接里跟上这个jsessionid的值即可，那么现在问题来了，这个jsessionid的值如何获取？</p>
</li>
<li><p>servlet里面通过请求对象requst对象.getsession.getid()获取到，当然这仅仅只能获取jseesionid的值，而使用Response.encodeURL则可以直接得到路径+jsessionid的全部url路径，不需要自己手动拼接字符串了。然后将这个url返回给客户端，用户通过一个链接点击一样可以解决cookie禁用，但session的数据依旧可以共享的问题。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>事件代理，哪些事件没有冒泡？</p>
<pre><code>load、unload、blur、focus、mouseleave、mouseleave
</code></pre></li>
<li><p>如何监听一个对象的值变化</p>
<ul>
<li>Object.defineProperty(obj, prop, descriptor)</li>
</ul>
</li>
<li><p>给一个场景 包含 搜索框 按钮  数据展示  分页  表单  你如何整理组件</p>
</li>
<li><p>某个用户反馈网站访问变慢，怎么去定位问题?</p>
<ol>
<li>看看自己这卡不卡</li>
<li>看调试哪项数据加载比较慢</li>
<li>看看服务器的负载情况，可以去查看下服务器硬件（网络带宽、CPU、内存）的消耗状况</li>
<li>后台有无错误日志打印</li>
<li>数据库过于庞大 -》拆表 拆库</li>
</ol>
</li>
<li><p>fetch和axios</p>
<ul>
<li><p>fetch:</p>
<ul>
<li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</li>
<li>更好更方便的写法</li>
<li>更加底层，提供的API丰富（request, response）</li>
<li>脱离了XHR，是ES规范里新的实现方式</li>
<li>1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</li>
<li>2）fetch默认不会带cookie，需要添加配置项</li>
<li>3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li>
<li>4）fetch没有办法原生监测请求的进度，而XHR可以</li>
</ul>
</li>
<li><p>axois</p>
<ul>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>从 node.js 发出 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防止CSRF/XSRF</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>阿里面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack配置由简至全</title>
    <url>/2018/02/12/2018-2-12-Webpack%E9%85%8D%E7%BD%AE%E7%94%B1%E7%AE%80%E8%87%B3%E5%85%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>###一、基本安装</p>
<ul>
<li><p>第一步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir project-name &amp;&amp; cd project-name</span><br><span class="line">$ npm init -y   //-y:跳过询问</span><br><span class="line">$ npm install webpack --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步<br>在当前目录创建index.html 、 index.js 和 webpack.config.js<br>|- package.json<br>|- index.html<br>|- src<br>|- webpack.config.js<br>&nbsp;&nbsp;&nbsp;&nbsp;|- index.js</p>
</li>
<li>第三步<code>html</code>&amp;<code>webpack.config.js</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>第四步<br>运行<code>webpack.config.js</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./node_modules/.bin/webpack --config webpack.config.js</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./node_modules/.bin/webpack --mode development --config  webpack.config.js</span><br><span class="line">Hash: e0686a5b50f610b48d10</span><br><span class="line">Version: webpack 4.10.2</span><br><span class="line">Time: 66ms</span><br><span class="line">Built at: 2018-05-31 19:21:18</span><br><span class="line">    Asset   Size  Chunks             Chunk Names</span><br><span class="line">bundle.js  4 KiB    main  [emitted]  main</span><br><span class="line">Entrypoint main = bundle.js</span><br><span class="line">[./src/index.js] 227 bytes &#123;main&#125; [built]</span><br></pre></td></tr></table></figure></p>
<p>自此我们已经完成了一个最简单的打包过程了</p>
<p>###二、完善<code>webpack.config.js</code>配置</p>
<ul>
<li><strong>1. HtmlWebpackPlugin插件  <code>//打包生成html文件</code></strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>webpack.config.js</code>中引入<code>html-webpack-plugin</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: __dirname + &quot;/index.html&quot;,  //目标文件</span><br><span class="line">        inject: true, //script标签位置； false:不插入js标签</span><br><span class="line">        minify: &#123;     //一些压缩操作 =&gt;自 create-react-app</span><br><span class="line">          removeComments: true,</span><br><span class="line">          collapseWhitespace: true, //折叠空格</span><br><span class="line">          removeRedundantAttributes: true,</span><br><span class="line">          useShortDoctype: true,</span><br><span class="line">          removeEmptyAttributes: true,</span><br><span class="line">          removeStyleLinkTypeAttributes: true,</span><br><span class="line">          keepClosingSlash: true,</span><br><span class="line">          minifyJS: true,</span><br><span class="line">          minifyCSS: true,</span><br><span class="line">          minifyURLs: true,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>2 . module –为了识别各种文件</strong></li>
</ul>
<p>为了从 JavaScript 模块中 import 一个 CSS 文件<br> 首先下载loaders:<br> <code>$ npm install --save-dev style-loader css-loader</code><br> 然后</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,//根据正则匹配css后缀的文件</span><br><span class="line">     use: [</span><br><span class="line">        &apos;style-loader&apos;,</span><br><span class="line">        &apos;css-loader&apos;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>其他类似，根据所用文件来使用相应解析器，如</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],</span><br><span class="line">    loader: require.resolve(&apos;url-loader&apos;),</span><br><span class="line">    options: &#123; </span><br><span class="line">        limit: 1024,</span><br><span class="line">        name: &apos;static/media/[name].[hash:8].[ext]&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><strong>3 . hash | chunkhash | contenthash –为了解决缓存问题</strong><br>写法：<code>filename: &#39;[name].[chunkhash:8].js&#39;</code><ul>
<li><code>hash</code>：一个版本一个独一无二的hash<ul>
<li>（全部文件都共用相同的hash值）</li>
</ul>
</li>
<li><code>chunkhash</code>：一个模块独一无二的hash<ul>
<li>（只要模块不改变，chunkhash不变）</li>
</ul>
</li>
<li><code>contenthash</code>：一个文件独一无二的hash<ul>
<li>（文件改变内容，contenthash即改变） </li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里hash值改变就会产生一个问题：打包后的文件会始终叠加<br>因此需要用一个删除文件的插件<code>clean-webpack-plugin</code><br><code>new CleanWebpackPlugin(pathsToClean)//pathsToClean:&#39;dist&#39;</code></p>
</blockquote>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas 基础以及2048游戏实践</title>
    <url>/2018/11/20/canvas%20%E5%9F%BA%E7%A1%80%E4%BB%A5%E5%8F%8A2048%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>canvas（画布）：顾名思义用来画画的容器 ta 本领很大 可以实现 ps 上大部分功能</p>
</blockquote>
<p><img src="/images/2048.jpg" alt="2048游戏"></p>
<a id="more"></a>
<h2 id="1-点"><a href="#1-点" class="headerlink" title="1. 点"></a>1. 点</h2><p><code>context.moveTo(x,y)</code>。这句代码的意思是 移动画笔至(x,y)这个点（单位是 px）。这里是以 canvas 画布的左上角为笛卡尔坐标系的原点，且 y 轴的正方向向下，x 轴的正方向向右。</p>
<h2 id="2-线"><a href="#2-线" class="headerlink" title="2. 线"></a>2. 线</h2><ul>
<li><p>起点：<code>context.moveTo(x,y)</code>：同点</p>
</li>
<li><p>终点：<code>context.lineTo(x,y)</code>。这句的意思是从 上一笔的停止点 绘制到(x,y)这里。 这里我们只是定义了路径，而未真正开始绘制。折线继续 <code>lineTo</code> 就可以了。</p>
</li>
</ul>
<h2 id="3-面"><a href="#3-面" class="headerlink" title="3. 面"></a>3. 面</h2><p>面其实就是把折线内容闭合就可以形成多边形了，因此只要在绘制后通过 <code>closePath()</code> 就可以将内容闭合了。下面是一个矩形的例子(里面包含了常用的一些属性)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>绘制矩形<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"canvas-warp"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">canvas</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">"canvas"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">"800"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">height</span>=<span class="string">"600"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"border: 1px solid #aaaaaa; display: block; margin: 50px auto;"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        你的浏览器居然不支持Canvas</span><br><span class="line">      <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> context = canvas.getContext(<span class="string">"2d"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 添加渐变线 （与PS的渐变线是一样的）</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> grd = context.createLinearGradient(<span class="number">400</span>, <span class="number">50</span>, <span class="number">400</span>, <span class="number">550</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 径向渐变 （两圆之间的渐变）</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// const grd = context.createRadialGradient(400, 300, 0, 400, 300, 250);</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 填充纹理 repeat-x | -y | no-repeat</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// const pattern = context.createPattern(img,"repeat");</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//添加颜色断点</span></span></span><br><span class="line"><span class="javascript">        grd.addColorStop(<span class="number">0</span>, <span class="string">"#94e6ff"</span>)</span></span><br><span class="line"><span class="javascript">        grd.addColorStop(<span class="number">0.5</span>, <span class="string">"white"</span>)</span></span><br><span class="line"><span class="javascript">        grd.addColorStop(<span class="number">1</span>, <span class="string">"#94e6ff"</span>)</span></span><br><span class="line"></span><br><span class="line">        context.beginPath()</span><br><span class="line">        context.moveTo(150, 50)</span><br><span class="line">        context.lineTo(650, 50)</span><br><span class="line">        context.lineTo(650, 550)</span><br><span class="line">        context.lineTo(150, 550)</span><br><span class="line"><span class="javascript">        context.closePath() <span class="comment">// 闭合路径</span></span></span><br><span class="line"><span class="javascript">        context.lineWidth = <span class="number">2</span> <span class="comment">// 设置线宽</span></span></span><br><span class="line"><span class="javascript">        context.strokeStyle = <span class="string">"black"</span> <span class="comment">// 设置线色</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        context.fillStyle = grd <span class="comment">// 选择油漆桶的颜色 当然也可以是具体的纯色</span></span></span><br><span class="line"><span class="javascript">        context.fill() <span class="comment">// 绘制路径方法</span></span></span><br><span class="line">        context.stroke()</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-圆弧"><a href="#4-圆弧" class="headerlink" title="4. 圆弧"></a>4. 圆弧</h2><ul>
<li><p>标准圆弧：<code>arc()</code><br>参数：(x, y, radius, startAngle,endAngle,anticlockwise)<br>前面三个参数，分别是圆心坐标与圆半径。<br>startAngle、endAngle 是弧度值，不是角度值。<br>anticlockwise：是否逆时针绘制 默认 false(顺时针)</p>
</li>
<li><p>复杂圆弧：<code>arcTo()</code><br>参数：(x1,y1,x2,y2,radius)<br>两个切点家圆弧半径确定</p>
</li>
<li><p>二次贝塞尔曲线：<code>quadraticCurveTo()</code><br>参数：(cpx,cpy,x,y)<br>这里经常配合 <code>moveTo(x0, y0)</code>给出起始切点 cpx, cpy 作为控制点<br>x, y 为结束点<br>这里有一个 <a href="http://tinyurl.com/html5quadratic/" target="_blank" rel="noopener">在线转换器</a></p>
</li>
<li><p>三次贝塞尔曲线：<code>bezierCurveTo()</code><br><code>context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)</code><br>较二次曲线多了一个控制点,正常情况下二次已经足够了,三次能画出更加复杂的东西。<br><a href="http://tinyurl.com/html5bezier" target="_blank" rel="noopener">在线转换器</a></p>
</li>
</ul>
<h2 id="5-变换"><a href="#5-变换" class="headerlink" title="5.变换"></a>5.变换</h2><ul>
<li><p>平移变换 <code>translate(x,y)</code><br>例如我想将位于（0，0）的矩形平移至（100，100）点。那么我只要在绘制矩形之前加上 context.translate(100,100)</p>
</li>
<li><p>旋转变换 <code>rotate(deg)</code><br>需要注意的是，旋转是以坐标系的原点（0，0）为圆心进行的顺时针旋转。所以，在使用<code>rotate()</code>之前，需要配合使用<code>translate()</code>平移坐标系，确定旋转的圆心。</p>
</li>
<li><p>缩放变换 <code>scale(sx,sy)</code><br>注意：这个缩放是整体缩放 包括了<strong>位置</strong> 和 <strong>线宽</strong>, 所以我们最好是把左上角位置为(0, 0)，不设置线宽。或者自己封装。</p>
</li>
<li><p>矩阵变换 <code>transform(a,b,c,d,e,f)</code><br>以上变换都可以用矩阵变换去实现，<br>[a, c, e]<br>|b, d, f|<br>[0, 0, 1]<br>| 参数 | 含义 | 默认值 |<br>| :–: | :–: | :—:|<br>| a | 水平缩放 | 1<br>| b | 水平倾斜 | 0<br>| c | 垂直倾斜 | 0<br>| d | 垂直缩放 | 1<br>| e | 水平位移 | 0<br>| f | 垂直位移 | 0</p>
<p>默认值带入后其实就是一个单位矩阵<br>可以经过简单的矩阵换算得出以下结论</p>
<ol>
<li>使用 context.transform (1,0,0,1,dx,dy)代替 context.translate(dx,dy)</li>
<li>使用 context.transform(sx,0,0,sy,0,0)代替 context.scale(sx, sy)</li>
<li>使用 context.transform(0,b,c,0,0,0)来实现倾斜效果(最实用)。</li>
</ol>
</li>
<li><p><code>setTransform()</code> 是重置并开始变换，相当于做了一次<code>restore</code></p>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>canvas 内容说多也不多，其他还有 font 相关、shadow 相关 以及 clip 相关等 API</li>
<li>最后附上游戏链接 <a href="/2048game/2048.html">2048 游戏</a> (ps:最近比较忙 分值以及动效等会补上~ 个人觉得就 2048 而言操作 div 会更加简单哦)</li>
</ul>
]]></content>
      <categories>
        <category>html5/css3</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack3配置由简至全（二）</title>
    <url>/2018/02/12/2018-2-14-Webpack%E9%85%8D%E7%BD%AE%E7%94%B1%E7%AE%80%E8%87%B3%E5%85%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>###二、完善<code>webpack.config.js</code>配置（2）</p>
<ul>
<li><p><strong>4. 为了开发-开发工具</strong><br>官网<a href="https://webpack.js.org" target="_blank" rel="noopener">https://webpack.js.org</a>有介绍三种开发工具</p>
<ol>
<li>webpack’s Watch Mode</li>
<li>webpack-dev-server</li>
<li><p>webpack-dev-middleware</p>
<p>这里选用一个较为常用的—<code>webpack-dev-server</code><br>首先下载依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p><em>webpack.config.js</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  const path = require(&apos;path&apos;);</span><br><span class="line">  const webpack = require(&apos;webpack&apos;);</span><br><span class="line">  const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">  const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">  module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].[chunkhash:8].js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">+   devServer: &#123;</span><br><span class="line">+     contentBase: &apos;./dist&apos;</span><br><span class="line">+   &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      new CleanWebpackPlugin([&apos;dist&apos;]),</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在<code>package.json</code>脚本行添加 <code>&quot;start&quot;: &quot;webpack-dev-server --open&quot;</code><br>最后通过<code>npm run start</code> 就可以开启一个简单的本地服务</p>
<hr>
<ul>
<li><strong>5. 为了开发-热加载</strong><br>这里使用<code>webpack-dev-server</code>配置热加载<br>注意：热加载和<code>chunkhash</code>冲突 这里改为<code>hash</code><br><em>webpack.config.js</em><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  const path = require(&apos;path&apos;);</span><br><span class="line">  const webpack = require(&apos;webpack&apos;);</span><br><span class="line">  const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">  const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">  module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].[hash:8].js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">+   devServer: &#123;</span><br><span class="line">+     contentBase: &apos;./dist&apos;</span><br><span class="line">+     historyApiFallback: true,//任意的跳转或404响应可以指向首页；</span><br><span class="line">+     inline: true,   //一般启用inline方式热更新</span><br><span class="line">+     hot: true,</span><br><span class="line">+   &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      new CleanWebpackPlugin([&apos;dist&apos;]),</span><br><span class="line">+     new webpack.NamedModulesPlugin(),   //热加载显示模块的相对路径</span><br><span class="line">+     new webpack.HotModuleReplacementPlugin(),   //启用热加载模块</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样就把热加载项配置好了<br>当然热加载还不止这点 -&gt;<a href="https://webpack.js.org/guides/hot-module-replacement/#hmr-with-stylesheets" target="_blank" rel="noopener">热加载参考</a></p>
<hr>
<ul>
<li><strong>6. 添加<code>postcss-loader</code></strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.css$/,</span><br><span class="line">    use: [</span><br><span class="line">        require.resolve(&apos;style-loader&apos;),</span><br><span class="line">        &#123;</span><br><span class="line">            loader: require.resolve(&apos;css-loader&apos;),</span><br><span class="line">            options: &#123;</span><br><span class="line">                importLoaders: 1,  //接下来的需要的loader个数</span><br><span class="line">                modules: true,     //模块化css</span><br><span class="line">                localIdentName: &apos;[local]_[hash:base64:5]&apos; //css名称</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: require.resolve(&apos;postcss-loader&apos;),</span><br><span class="line">            options: &#123;</span><br><span class="line">                ident: &apos;postcss&apos;,</span><br><span class="line">                plugins: () =&gt; [</span><br><span class="line">                    require(&apos;postcss-flexbugs-fixes&apos;),</span><br><span class="line">                    autoprefixer(&#123;</span><br><span class="line">                        browsers: [</span><br><span class="line">                            &apos;&gt;1%&apos;,</span><br><span class="line">                            &apos;last 4 versions&apos;,</span><br><span class="line">                            &apos;Firefox ESR&apos;,</span><br><span class="line">                            &apos;not ie &lt; 9&apos;, // React doesn&apos;t support IE8 anyway</span><br><span class="line">                        ],</span><br><span class="line">                        flexbox: &apos;no-2009&apos;,</span><br><span class="line">                    &#125;),</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><strong>7. 公共文件抽取<code>DllPlugin</code></strong>大大加快编译速度<br>首先我选择在根目录下新增一个<code>webpack.dll.config.js</code>文件并配置好内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const webpack = require(&quot;webpack&quot;);</span><br><span class="line">const _package = require(&apos;./package.json&apos;); // 引入package.json</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        vendor: Object.keys(_package.dependencies) // 遍历package.json的所有依赖包</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &apos;build&apos;), // 生成的文件存放路径</span><br><span class="line">        filename: &apos;[name].dll.js&apos;, // 生成的文件名字(默认为vendor.dll.js)</span><br><span class="line">        library: &apos;[name]_library&apos;  // 生成文件的映射关系，与下面DllPlugin中配置对应</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DllPlugin(&#123;</span><br><span class="line">            // 会生成一个json文件，里面是关于dll.js的一些配置信息</span><br><span class="line">            path: path.join(__dirname, &apos;public&apos;, &apos;[name]-manifest.json&apos;),</span><br><span class="line">            name: &apos;[name]_library&apos;, // 与上面output中配置对应</span><br><span class="line">            context: __dirname // 上下文环境路径</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后在<code>package.json</code>中配置启动</p>
<pre><code>&quot;dll&quot;:&quot;webpack --config webpack.dll.config.js --progress&quot;
执行 npm run dll =&gt;生成依赖映射文件
</code></pre><p>最后在我们的<code>webpack.dev.config.js</code>plugin 中加入DllReferencePlugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new webpack.DllReferencePlugin(&#123;</span><br><span class="line">            context: __dirname,</span><br><span class="line">            manifest: path.join(__dirname, &quot;public&quot;,&quot;vendor-manifest.json&quot;)//dll生成的映射json路径</span><br><span class="line">        &#125;),</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：我们需要把dll生成的公共js文件需要在bundle.js之前引入才行<br>现在我们就可以开始npm run dev 实现快速编译了</p>
</blockquote>
<hr>
<ul>
<li>**8. 配置eslint帮助我们检查代码，大大提高开发效率<br>  -&gt; <a href="https://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">Eslint参考文献</a><br>  -&gt; <a href="http://eslint.cn/docs/user-guide/configuring" target="_blank" rel="noopener">Eslint中文</a><br>  这个配置因人而异，很多编辑器可以直接引入eslint插件实现代码检测，就无需配置这个了，反而影响编译速度<ul>
<li>start：老规矩先装依赖(这里使用<code>airbnb</code>编译规则，有自己的规则可以在<code>.eslintrc</code>相关文件上编写自己的rules)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev eslint</span><br><span class="line">eslint --init//这里根据需求走 我们选择popular -&gt; bnb</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>由于是代码检测工具所以我们需要放在js执行前</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    test: /\.(js|jsx|mjs)$/,</span><br><span class="line">    enforce: &apos;pre&apos;,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;</span><br><span class="line">        options: &#123;</span><br><span class="line">            formatter: eslintFormatter,//这个输出格式可以网上找或者自己写，传入一个eslint解析的结果，需要返回打印内容可以使用 &apos;eslint-friendly-formater&apos;</span><br><span class="line">            eslintPath: require.resolve(&apos;eslint&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">        loader: require.resolve(&apos;eslint-loader&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    include: `$&#123;__dirname&#125;`,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p> <code>eslintFormatter.js</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">const chalk = require(&apos;chalk&apos;);</span><br><span class="line">const table = require(&apos;text-table&apos;);</span><br><span class="line"></span><br><span class="line">function isError(message) &#123;</span><br><span class="line">  if (message.fatal || message.severity === 2) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function formatter(results) &#123;</span><br><span class="line">  let output = &apos;\n&apos;;</span><br><span class="line">  let hasErrors = false;</span><br><span class="line">  let reportContainsErrorRuleIDs = false;</span><br><span class="line"></span><br><span class="line">  results.forEach(result =&gt; &#123;</span><br><span class="line">    let messages = result.messages;</span><br><span class="line">    if (messages.length === 0) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    messages = messages.map(message =&gt; &#123;</span><br><span class="line">      let messageType;</span><br><span class="line">      if (isError(message)) &#123;</span><br><span class="line">        messageType = &apos;error&apos;;</span><br><span class="line">        hasErrors = true;</span><br><span class="line">        if (message.ruleId) &#123;</span><br><span class="line">          reportContainsErrorRuleIDs = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        messageType = &apos;warn&apos;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let line = message.line || 0;</span><br><span class="line">      let position = chalk.bold(&apos;Line &apos; + line + &apos;:&apos;);</span><br><span class="line">      return [</span><br><span class="line">        &apos;&apos;,</span><br><span class="line">        position,</span><br><span class="line">        messageType,</span><br><span class="line">        message.message.replace(/\.$/, &apos;&apos;),</span><br><span class="line">        chalk.underline(message.ruleId || &apos;&apos;),</span><br><span class="line">      ];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // if there are error messages, we want to show only errors</span><br><span class="line">    // if (hasErrors) &#123;</span><br><span class="line">    //   messages = messages.filter(m =&gt; m[2] === &apos;error&apos;);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // add color to rule keywords</span><br><span class="line">    messages.forEach(m =&gt; &#123;</span><br><span class="line">      console.log(m[4])</span><br><span class="line">      m[4] = m[2] === &apos;error&apos; ? chalk.red(m[4]) : chalk.yellow(m[4]);</span><br><span class="line">      m.splice(2, 1);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let outputTable = table(messages, &#123;</span><br><span class="line">      align: [&apos;l&apos;, &apos;l&apos;, &apos;l&apos;],</span><br><span class="line">      stringLength(str) &#123;</span><br><span class="line">        return str.length;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    output += `$&#123;outputTable&#125;\n\n`;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // if (reportContainsErrorRuleIDs) &#123;</span><br><span class="line"></span><br><span class="line">  //   output +=</span><br><span class="line">  //     &apos;Search for the &apos; +</span><br><span class="line">  //     chalk.underline(chalk.red(&apos;keywords&apos;)) +</span><br><span class="line">  //     &apos; to learn more about each error.&apos;;</span><br><span class="line">  // &#125;</span><br><span class="line">  return output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = formatter;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>OK,基本配置完结，现在基本的功能都已经有了，再来就是可以封装一下方法啥的！</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>webpack3</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>《高级程序设计》整理(一)- - -数据类型和数组篇</title>
    <url>/2018/03/20/2018-3-20-%E3%80%8A%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E6%95%B4%E7%90%86-%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E7%BB%84%E7%AF%87/</url>
    <content><![CDATA[<hr>
<p>###一、JavaScript六种数据类型 </p>
<ol>
<li><p>Undefined == <code>Boolean</code>  ==》等于<code>true</code></p>
</li>
<li><p>Null:表示一个空指针对象 <code>typeof(null)===&quot;object&quot;</code></p>
</li>
<li><p>Boolean:true / false</p>
</li>
<li><p>Number  <code>NAN==NAN</code> ==》<code>false</code><br>- - -|  <code>isNAN(true)=1</code><br>- - -|  <code>Number(null) = 0</code> - - <code>Number(&quot;&quot;) = 0</code>   对于各种进制的字符串将其转换成相同大小的十进制– –&gt;更常用的是<code>parsent(&quot;&quot;)=NAN</code> - - <code>parsent(&quot;070&quot;)=56</code> ES3识别成八进制 ES5识别成70—-&gt;<code>parsent(&quot;070&quot;,8)</code> 八进制</p>
</li>
<li><p>String<br>- - -|  <code>toString(2|8|10|16)</code>   null/undefined 没有toString方法<br>- - -|  转型函数String()  如果有<code>tostring()</code>方法则调用他 如果是 null/undefined —&gt;”null”/“undefined”</p>
</li>
</ol>
<a id="more"></a>
<ol start="6">
<li>Object(所有对象的基础)<br>- - -|  <code>constructor</code>  保存着用于创建当前对象的函数<br>   - - -|  <code>toString()  ≈ valueOf()</code><br>   - - -|  <code>hasOwnProperty(propertyName)</code>检测指定属性是否在当前对象实例中（不包括原型实例）<br>   - - -| <code>toLocalString()</code> 返回地区化的值 用的比较多的就是 本地时间格式<br>   - - -|  <code>propertyIsEnumerable()</code> （检测指定属性能否用for-in枚举）<blockquote>
<p>检测数据类型 <code>typeof</code> (区分 字符串/数值/布尔值/undefined)<br> 当检测数据是引用类数据时 <code>instanceof</code> 它根据原型链识别（测试实例和原型链中出现过的构造函数 如果有返回true）</p>
</blockquote>
</li>
</ol>
<p>###二、数组方法</p>
<ol>
<li><p>栈方法（Last-In-First-Out）<br>- - -|  在JavaScript中数组的 <code>push()</code> 和 <code>pop()</code> 行为类似堆栈出栈 push返回最终数组长度 pop返回数组中最后一项</p>
</li>
<li><p>队列方法（First-In-First-Out）<br>- - -|  在JavaScript中数组的 <code>push()</code> 和 <code>shift()</code> 行为类似堆栈出栈 push返回最终数组长度 shift()返回数组中第一项<br> - - -|  <code>unshift()</code> 和 <code>shift()</code> 相反–&gt;可以向数组前端推入项并返回新的长度  <code>unshift()</code> 和 <code>pop()</code>组合可以实现反向队列</p>
</li>
<li><p>重排序方法<br>- - -|  数组有<code>sort()</code>  和  <code>reverse()</code>  两个方法 – </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort(fun)</span><br><span class="line">接收一个比较函数Fun(num1,num2) </span><br><span class="line">		num1&lt;num2 ==&gt; -1</span><br><span class="line">		num1=num2 ==&gt;0</span><br><span class="line">		num1&gt;num2 ==&gt; 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作方法<br>- - -|  <code>concat()</code>  组成新数组<br>- - -| <code>slice(start ,end)</code>  截取数组但不改变原数组  对应字符串方法 <code>subString()</code><br>- - -| <code>splice(start, length, another)</code>  数组中最常用的方法  可完成数组删除、插入、替换操作</p>
</li>
<li><p>位置方法<br>- - -|  <code>IndexOf(needSearch, startpos)</code>  返回查找项索引   —–    <code>LastIndexOf</code> 查找方向相反</p>
</li>
</ol>
<ol start="6">
<li>迭代方法<br>- - -|  <code>arr.every(function(item,index,array)</code>     对每一项都返回true才返回true<br>   - - -|  <code>arr.some(function(item,index,array)</code>      当某项符合时返回true<br>   - - -|  <code>hasOwnProperty(propertyName)</code> 检测指定属性是否在当前对象实例中（不包括原型实例）<br>   - - -| <code>arr.filter(function(item,index,array)</code>      返回符合条件的集合<br>   - - -| <code>arr.forEach(function(item,index,array)</code> 对每一项进行操作 无返回 （无法终止循环除非抛出异常）<br> - - -| <code>arr.map(function(item,index,array)</code>      返回给定条件的数组</li>
</ol>
<ol start="7">
<li>归并方法（reduce/reduceRight）<br>- - -| <code>arr.reduce(function(prev, cur, index, array)</code><pre><code>var values = [1,2,3,4,5]; 
var sum = values.reduce(function(prev, cur, index, array){ 
    return prev + cur; 
}); 
alert(sum); //15
</code></pre><blockquote>
<p>第一次执行回调函数，prev 是1，cur 是2。第二次，prev 是3（1 加2 的结果），cur 是3（数组 </p>
<pre><code>的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。 
`resuceRight()`函数和reduce类似，不过是倒序。
</code></pre></blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>《高级程序设计》整理(三)- - -JS对象</title>
    <url>/2018/03/20/2018-3-20-%E3%80%8A%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E6%95%B4%E7%90%86-%E4%B8%89-JS%E5%AF%B9%E8%B1%A1-1/</url>
    <content><![CDATA[<p>JS对象<br>一、属性类型</p>
<ol>
<li><p>数据属性</p>
<ul>
<li><p>[[Configurable]]<br>表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认值为true。</p>
</li>
<li><p>[[Enumerable]]<br>表示能否通过<code>for-in</code>循环返回属性。直接在对象上定义的属性，默认值为true。</p>
</li>
<li><p>[[Writable]]<br>表示能否修改属性的值。直接在对象上定义的属性，默认为true。</p>
</li>
<li><p>[[Value]]<br>包含这个属性的数据值；读取属性值的时候，从这个位置读取；写入属性值的时候，把值保存在这里。默认为undefined。</p>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<ol start="2">
<li><p>访问器属性- 属性有getter和setter方法，(读/写属性)。</p>
<ul>
<li><p>[[Configurable]]<br>表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认值为true。</p>
</li>
<li><p>[[Enumerable]]<br>表示能否通过<code>for-in</code>循环返回属性。直接在对象上定义的属性，默认值为true。</p>
</li>
<li><p>[[get]]<br>在读取属性时调用的函数；默认值为undefined。</p>
</li>
<li><p>[[set]]<br>在写入属性时调用的函数；默认值为undefined。</p>
</li>
</ul>
<blockquote>
<p><code>Object.defineProperty(obj, prop, descriptor)</code>:方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   var person = &#123;&#125;</span><br><span class="line">   Object.defineProperty(person, &apos;name&apos;, &#123;</span><br><span class="line">        writable:false,</span><br><span class="line">        value:jiaying</span><br><span class="line">&#125;);</span><br><span class="line">person.name = zeqing  //严格模式下报错 </span><br><span class="line"> &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><code>Object.defineProperties(obj, props)</code>:方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var person = &#123;&#125;</span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  Object.defineProperties(obj, &#123;</span><br><span class="line">      &apos;property1&apos;: &#123;</span><br><span class="line">          value: true,</span><br><span class="line">          writable: true</span><br><span class="line">  &#125;,</span><br><span class="line">      &apos;property2&apos;: &#123;</span><br><span class="line">          value: &apos;Hello&apos;,</span><br><span class="line">          writable: true</span><br><span class="line">  &#125;, </span><br><span class="line">      &apos;property3&apos;: &#123;</span><br><span class="line">          get: function() &#123;</span><br><span class="line">              return this[&apos;property2&apos;]</span><br><span class="line">          &#125;,</span><br><span class="line">          set: function(newValue) &#123;</span><br><span class="line">              this[&apos;property2&apos;] = newValue;</span><br><span class="line">              this[&apos;property1&apos;] = false;</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // etc. etc.</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>-<code>Object.getOwnPropertyDescriptor(obj, prop)</code>方法，可以取得给定属性的描述符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperties(person, &#123;</span><br><span class="line">    _name: &#123;</span><br><span class="line">        value: &quot;CC&quot;,</span><br><span class="line">        writable: false</span><br><span class="line">    &#125;,</span><br><span class="line">    _age: &#123;</span><br><span class="line">        value: 23,</span><br><span class="line">        writable: true</span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            return this._age</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(newValue) &#123;</span><br><span class="line">            this._age = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;);</span><br><span class="line">var descriptor = Object.getOwnPropertyDescriptor(person, &quot;_age&quot;);</span><br><span class="line">console.log(descriptor.value);       //&quot;23&quot;</span><br><span class="line">console.log(descriptor.writable);    //true</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>《高级程序设计》整理(二)- - -正则与函数篇</title>
    <url>/2018/03/20/2018-3-20-%E3%80%8A%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E6%95%B4%E7%90%86-%E4%BA%8C-%E6%AD%A3%E5%88%99%E4%B8%8E%E5%87%BD%E6%95%B0%E7%AF%87/</url>
    <content><![CDATA[<p>《高级程序设计》整理(二)- - -正则与函数篇</p>
<hr>
<p>###一、正则（RegExp）<br> &nbsp; &nbsp; - - -| let pattern = / patern / ( i | g | m )    i:忽略大小写  g:全局匹配  m:多行匹配<br> &nbsp; &nbsp; &nbsp; &nbsp; （元字符需要转义—-&gt; ‘ ( { \ ^ $ | ) ? * + . ] } ‘ ）</p>
<p> &nbsp; &nbsp;  - - -|   RegExp的实例属性：<code>global</code>、<code>ignoreCase</code>、<code>multiline</code> 表示是否设置了该标志</p>
<a id="more"></a>
<p> &nbsp; &nbsp; - - -|  RegExp的实例方法：<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;— <code>exec()</code>: 包含第一个匹配项信息的数组（[match[0],match[1],match[2]…]）；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index（匹配项的索引）和input（输入）。<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;— <code>test()</code>:   /.*/.test(str) ==&gt;boolean  常用于if语句</p>
<p> &nbsp; &nbsp; - - -|  RegExp的构造函数属性：<br>| 长属性名    | 短属性名    |  说明  |<br>|——–| :—–:| —- |<br>| input        | $_      |   最近一次要匹配的字符串。Opera未实现此属性    |<br>| lastMatch        | $&amp;      |   最近一次的匹配性。 Opera未实现此属性    |<br>| lastParen        | $+      |   最近一次匹配的捕获组。 Opera未实现此属性    |<br>|leftContext    |$<code>|input字符串中lastMatch之前的文本|
|multiline    |$*|布尔值，是否所有表达式都使用多行模式。IE和Opera未实现此属性|
|rightContext|$·|input字符串中lastMatch之后的文本|
||\$1、\$2、\$3...|第一、第二、第三...匹配的捕获组 （</code>常用`）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var text=&quot;this has been a short summer&quot;;</span><br><span class="line">var pattern=/(.)hort/g;</span><br><span class="line">/*</span><br><span class="line">*注意：Opera不支持input、lastMatch、lastParen和multiline属性</span><br><span class="line">*IE 不支持multiline属性</span><br><span class="line">*/</span><br><span class="line">if(pattern.test(text))</span><br><span class="line">&#123;</span><br><span class="line">    alert(RegExp.$_); // this has been a short summer</span><br><span class="line">    alert(RegExp.[&quot;$`&quot;]); //this has been a   </span><br><span class="line">    alert(RegExp.[&quot;$·&quot;]); //summer</span><br><span class="line">    alert(RegExp.[&quot;$&amp;&quot;]); //short    </span><br><span class="line">    alert(RegExp.[&quot;$+&quot;]); //s</span><br><span class="line">    alert(RegExp.[&quot;$*&quot;]); //false</span><br><span class="line">    alert(RegExp.[&quot;$1&quot;]); //s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###四、Function类型</p>
<ol>
<li>每个函数都是function类型的实例，*即函数是对象，而函数名是指针<br>- - -|  函数的两种定义方式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1.function sum(num1, num2) &#123;//函数声明</span><br><span class="line">		return num1 + num2</span><br><span class="line">	&#125;</span><br><span class="line">2.var sum = function(num1, num2) &#123;//函数表达式</span><br><span class="line">		return num1 + num2</span><br><span class="line">	&#125;;</span><br><span class="line">*注意：用不含括号的函数名访问的是函数指针，而非调用函数</span><br><span class="line">		 即：var anotherSum = sum </span><br><span class="line">				 sum = null</span><br><span class="line">		         anotherSum(10,10)  //==&gt;20</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li>函数声明和函数表达式<br>- - -|  解析器会将函数声明提升，率先解析函数声明并生成引用;<br>- - -|  表达式则是按解析顺序自上而下执行。</li>
</ol>
<ol start="3">
<li><p>函数内部属性（arguments, this）<br>- - -|  this：引用函数的执行环境</p>
<p>- - -|  arguments：<strong>类数组</strong>对象，包含传入函数的所有参数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - -  callee：<code>arguments.callee()</code>指向拥有该arguments对象的函数；常用于递归解耦<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - -  arguments[<code>Symbol.iterator</code>]()：返回一个新的Array迭代器对象，该对象包含参数中每个索引的值。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> /*将arguments转成数组对象的方法*/</span><br><span class="line">var args = Array.prototype.slice.call(arguments);</span><br><span class="line">var args = [].slice.call(arguments);</span><br><span class="line">const args = Array.from(arguments);// ES2015</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>函数属性和方法<br>-  - 属性:length：函数希望接收的参数个数；prototype：保存所有实例方法<br>-  - 方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–apply()和call():</p>
<blockquote>
<p>每个函数都包含两个非继承而来的方法：<code>apply()</code>和<code>call()</code>。这两个方法的用途都是在特定的作用域中调用函数，实际上等于函数体内<code>this</code>对象的值; 他们的第一参数都是作用域,<code>apply()</code>的第二参数为数组而<code>call()</code>则需将传递参数列举出来。<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  function sum(num1, num2)&#123;</span><br><span class="line">      return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum1(num1, num2)&#123;</span><br><span class="line">    return sum.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">console.log(callSum1(10,10));//20</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>扩充作用域-&gt;例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123; color: &quot;blue&quot; &#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line"> alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); //red</span><br><span class="line">sayColor.call(this); //red</span><br><span class="line">sayColor.call(window); //red</span><br><span class="line">sayColor.call(o); //blue</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong><code>bind()</code></strong>:<br>call() / apply() ,都是立马就调用了对应的函数，而 <code>bind()</code> 不会， <code>bind()</code> 会生成一个新的函数，bind() 函数的参数跟 call() 一致,可以随时调用。<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123; color: &quot;blue&quot; &#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line"> alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">var objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); //blue</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux实践——减少样板代码</title>
    <url>/2018/05/27/2018-5-27-Redux%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%87%8F%E5%B0%91%E6%A0%B7%E6%9D%BF%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>在编写 Redux 代码时，可能最令人感到厌烦的是必须写一大堆样板代码。在编写同步 action 时还能忍受，但在编写异步 action 时，大量的样板代码不仅使代码量陡增，而且难以维护。接下来我们就来探究如何使用<code>高阶函数（High-order Function）</code>和<code>中间件（middleware）</code>减少样板代码。</p>
<a id="more"></a>
<h2 id="同步-action"><a href="#同步-action" class="headerlink" title="同步 action"></a>同步 action</h2><p>以一个 todo 应用为例，具有新增、编辑、删除功能。完整代码如下：</p>
<p><code>actions/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EDIT_TODO = <span class="string">'EDIT_TODO'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DELETE_TODO = <span class="string">'DELETE_TODO'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = <span class="function"><span class="params">text</span> =&gt;</span> (&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  text</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EditTodo = <span class="function">(<span class="params">id, text</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: EDIT_TODO,</span><br><span class="line">  text</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DeleteTodo = <span class="function"><span class="params">id</span> =&gt;</span> (&#123;</span><br><span class="line">  type: DELETE_TODO,</span><br><span class="line">  id</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样大量的样板代码是否令人厌烦？我们来写一个高阶函数，来生成这些 action：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAction</span>(<span class="params">type, ...argNames</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> action = &#123; type &#125;</span><br><span class="line">    argNames.forEach(<span class="function">(<span class="params">argName, index</span>) =&gt;</span> &#123;</span><br><span class="line">      action[argName] = args[index]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EDIT_TODO = <span class="string">'EDIT_TODO'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DELETE_TODO = <span class="string">'DELETE_TODO'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = createAction(ADD_TODO, <span class="string">'text'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> editTodo = createAction(EDIT_TODO, <span class="string">'id'</span>, <span class="string">'text'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deleteToto = createAction(DELETE_TODO, <span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件中使用</span></span><br><span class="line"><span class="comment">// components/App.js</span></span><br><span class="line">dispatch(addTodo(<span class="string">'someText'</span>))</span><br></pre></td></tr></table></figure>
<p>经过<code>createAction</code>这个高阶函数封装之后，编写同步 action 只需要一行，清晰明了。</p>
<p>因为 action type 在 action 和 reducer 中都需要引用，所以可以新建一个<code>actionTypes.js</code>，将 type 常量放置其中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── redux</span><br><span class="line">│   ├── actions</span><br><span class="line">│       ├── index.js</span><br><span class="line">│   ├── reducers</span><br><span class="line">│       ├── index.js</span><br><span class="line">│   ├── actionTypes.js // 放置action type常量</span><br></pre></td></tr></table></figure>
<p><code>actionTypes.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EDIT_TODO = <span class="string">'EDIT_TODO'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DELETE_TODO = <span class="string">'DELETE_TODO'</span></span><br></pre></td></tr></table></figure>
<p>在<code>actions/index.js</code>中引入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'../actionTypes'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addTodo = createAction(actionTypes.ADD_TODO, <span class="string">'text'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> editTodo = createAction(actionTypes.EDIT_TODO, <span class="string">'id'</span>, <span class="string">'text'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deleteToto = createAction(actionTypes.DELETE_TODO, <span class="string">'id'</span>)</span><br></pre></td></tr></table></figure>
<p>再来看 Reducer：</p>
<p><code>reducers/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'../actionTypes'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> actionTypes.ADD_TODO:</span><br><span class="line">      <span class="comment">// 只是个例子，暂时不处理id的问题</span></span><br><span class="line">      <span class="keyword">const</span> text = action.text.trim()</span><br><span class="line">      <span class="keyword">return</span> [...state, text]</span><br><span class="line">    <span class="keyword">case</span> actionTypes.EDIT_TODO:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> actionType.DELETE_TODO:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>满屏的<code>switch...case...</code>让人眼花，让我们来写一个生成 reducer 的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReducer</span>(<span class="params">initState, handlers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initState, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handlers.hasOwnProperty(action.type)) &#123;</span><br><span class="line">      <span class="keyword">return</span> handlers[action.type](state, action)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos = createReducer([], &#123;</span><br><span class="line">  [actionTypes.ADD_TODO](state, action) &#123;</span><br><span class="line">    <span class="keyword">const</span> text = action.text.trim()</span><br><span class="line">    <span class="keyword">return</span> [...state, text]</span><br><span class="line">  &#125;,</span><br><span class="line">  [actionTypes.EDIT_TODO](state, action) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [actionTypes.DELETE_TODO](state, action) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> rootReducer = combineReducer(&#123;</span><br><span class="line">  todos</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>假如<code>todos</code>中有复杂的数据处理，我们甚至能将其再次抽取出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodos</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newTodos = state.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 复杂的数据处理</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newTodos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todos = createReducer([], &#123;</span><br><span class="line">  [actionTypes.ADD_TODO]: addTodos</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样结构就会非常清晰，遵循<code>让每个函数只做一件事情</code>原则，当需求变更或者 bug 定位时，不会牵一发而动全身。</p>
<h2 id="异步-action"><a href="#异步-action" class="headerlink" title="异步 action"></a>异步 action</h2><p>此处使用的异步中间件为<code>redux-thunk</code>，这是最基础的一个异步中间件。也许今后会用到<code>redux-saga</code>等更加强大的中间件，其实原理是一样的，也是使用高阶函数进行一步一步的封装。</p>
<p>我们来写一个最基本的异步 action：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actionTypes.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_START = <span class="string">'SOME_START'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_SUCCESS = <span class="string">'SOME_SUCCESS'</span>；</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_FAILED = <span class="string">'SOME_FAILED'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//actions/index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'../actionTypes'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> someAction = <span class="function"><span class="params">params</span> =&gt;</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: actionTypes.SOME_START &#125;);</span><br><span class="line"></span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="comment">// ...一些参数</span></span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = response.data.data;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: actionTypes.SOME_SUCCESS, data &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> errorMsg = <span class="string">'someText'</span>;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: actionTypes.SOME_FAILED, errorMsg &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，一个最简单的异步 action，需要编写的代码量就在 30 行左右。然而在实际项目中，我们还会有大量的业务逻辑操作，如错误提示、数据处理等等。一个界面动辄十来个几十个接口，大量的样板代码令人厌烦。那么我们怎么处理这些样板代码呢？答案是<code>中间件（middleware）</code>。</p>
<p>我们所使用的<code>redux-thunk</code>就是一个中间件。以下是它的源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">thunkMiddleware</span>(<span class="params">&#123; dispatch, getState &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span></span><br><span class="line">    <span class="keyword">typeof</span> action === <span class="string">'function'</span> ? action(dispatch, getState) : next(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅 6 行，就能使我们编写异步 action，但这是远远不够的，接下来我们来编写自己的中间件。</p>
<p>我们可以看到，一个异步 action 涉及到 3 个同步 action 和一个 AJAX 请求，那么我们把它提取出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> someAction = <span class="function"><span class="params">params</span> =&gt;</span> (&#123;</span><br><span class="line">  types: [</span><br><span class="line">    actionTypes.SOME_START,</span><br><span class="line">    actionTypes.SOME_SUCCESS,</span><br><span class="line">    actionTypes.SOME_FAILED</span><br><span class="line">  ],</span><br><span class="line">  axiosAPI: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    axios(&#123;</span><br><span class="line">      <span class="comment">//一些参数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>解释这个 action 的中间件可以是下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; dispatch, getState &#125;) =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; types, axiosAPI &#125; = action</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不存在types属性，则交由下个中间件处理</span></span><br><span class="line">  <span class="keyword">if</span> (!types) &#123;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证types是否正确的数组</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="built_in">Array</span>.isArray(types) ||</span><br><span class="line">    types.length !== <span class="number">3</span> ||</span><br><span class="line">    !types.every(<span class="function"><span class="params">type</span> =&gt;</span> <span class="keyword">typeof</span> type === <span class="string">'string'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected types to be an array of three string types.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> axiosAPI !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected axiosAPI to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [startType, successType, failureType] = types</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: startType &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> axiosAPI()</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = response.data.data</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: successType, data &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: failureType, <span class="attr">errorMsg</span>: <span class="string">'sometext'</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个中间件并不能满足我们的实际需求。在实际项目中，一个异步请求往往伴随着消息提示，回调函数等等，如请求成功时弹出提示、关闭弹窗等等。就目前的项目而言，可以提炼出这些需求：</p>
<ul>
<li>函数回调（如关闭弹窗，发起另外的请求等）</li>
<li>消息提示（包括成功、错误提示）</li>
<li>不同的 errorCode 有不同的提示</li>
<li>后台返回数据的处理</li>
</ul>
<p>我们再对上面的 action 进行扩展：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">'antd'</span>; <span class="comment">// 引入atnd消息弹框组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messageCallback = &#123;</span><br><span class="line">  success: <span class="function"><span class="params">msg</span> =&gt;</span> message.success(msg),</span><br><span class="line">  failed: <span class="function"><span class="params">msg</span> =&gt;</span> message.failed(msg),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> someAction = <span class="function">(<span class="params">params</span>) =&gt;</span> (&#123;</span><br><span class="line">  types: [actionTypes.SOME_START, actionTypes.SOME_SUCCESS, actionTypes.SOME_FAILED],</span><br><span class="line">  axiosAPI: <span class="function"><span class="params">()</span> =&gt;</span> axios(&#123;</span><br><span class="line">    <span class="comment">//一些参数</span></span><br><span class="line">  &#125;),</span><br><span class="line">  callback: &#123;</span><br><span class="line">    <span class="comment">// 消息提示</span></span><br><span class="line">    messageSuccess: <span class="function">(<span class="params">msg = <span class="string">'请求成功！'</span></span>) =&gt;</span> messageCallback.success(msg),</span><br><span class="line">    messageFailed: <span class="function">(<span class="params">msg = <span class="string">'请求失败！'</span></span>) =&gt;</span> messageCallback.failed(msg),</span><br><span class="line">    <span class="comment">// 对应错误码处理</span></span><br><span class="line">    errorList: [&#123;</span><br><span class="line">      errorCode: <span class="number">1010</span>,</span><br><span class="line">      errorMsg: <span class="string">'登录状态失效'</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      errorCode: <span class="number">202</span>,</span><br><span class="line">      errorMsg: <span class="string">'信息重复'</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="comment">// 对后台返回数据处理</span></span><br><span class="line">    handleData: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数回调</span></span><br><span class="line">    callbackFunc: <span class="function">(<span class="params">dispatch, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 一些回调方法，如发起另外的action，data处理等</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>继续扩展我们的中间件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; dispatch, getState &#125;) =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; types, axiosAPI, callback = &#123;&#125; &#125; = action</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不存在types属性，则交由下个中间件处理</span></span><br><span class="line">  <span class="keyword">if</span> (!types) &#123;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证types是否正确的数组</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="built_in">Array</span>.isArray(types) ||</span><br><span class="line">    types.length !== <span class="number">3</span> ||</span><br><span class="line">    !types.every(<span class="function"><span class="params">type</span> =&gt;</span> <span class="keyword">typeof</span> type === <span class="string">'string'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected types to be an array of three string types.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> axiosAPI !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected axiosAPI to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected callback to be an object.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [startType, successType, failureType] = types</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为callback和它的属性都为可选项，所以添加默认值</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    messageSuccess = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    messageFailed = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    callbackFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    errorList = [],</span><br><span class="line">    handleData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125; = callback</span><br><span class="line"></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: startType &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> axiosAPI()</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; ErrCode, ErrMsg, data &#125; = response.data</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从errorList筛选出和后台返回的ErrCode对应的值</span></span><br><span class="line">      <span class="keyword">const</span> error = errorList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.errorCode === ErrCode)[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">let</span> errorMsg = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        errorMsg = error.errorMsg</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据后台返回的错误码进行处理</span></span><br><span class="line">      <span class="keyword">if</span> (ErrCode !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          dispatch(&#123; <span class="attr">type</span>: failureType, errorMsg &#125;)</span><br><span class="line">          <span class="keyword">return</span> errorMsg &amp;&amp; <span class="keyword">typeof</span> errorMsg === <span class="string">'string'</span></span><br><span class="line">            ? messageFailed(errorMsg)</span><br><span class="line">            : <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch(&#123; <span class="attr">type</span>: failureType, <span class="attr">errorMsg</span>: ErrMsg || <span class="string">'failed'</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span> messageFailed()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ErrCode === <span class="number">200</span>) &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">          type: successType,</span><br><span class="line">          data: handleData(data) || data</span><br><span class="line">        &#125;)</span><br><span class="line">        callbackFunc(dispatch, data)</span><br><span class="line">        <span class="keyword">return</span> messageSuccess()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error)</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: failureType, <span class="attr">errorMsg</span>: <span class="string">'sometext'</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成！这样我们就可以编写比较清晰的异步请求 action。</p>
<p>最后处理 reducer：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'../actionTypes'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用之前封装的createReducer</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  isRequesting: <span class="literal">false</span>,</span><br><span class="line">  data: [],</span><br><span class="line">  errorMsg: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> someReducer = createReducer(initState, &#123;</span><br><span class="line">  [actionTypes.SOME_START](state, action) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...state, <span class="attr">isRequesting</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [actionTypes.SOME_SUCCESS](state, action) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...state, <span class="attr">data</span>: action.data, <span class="attr">isRequesting</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [actionTypes.SOME_FAILED](state, action) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...state, <span class="attr">errorMsg</span>: action.errMsg, <span class="attr">isRequesting</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在编写 reducer 时我们会发现，异步请求的 reducer 往往具有相同的逻辑，即三种处理条件，我们试试将这些逻辑复用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createAsyncReducer = <span class="function">(<span class="params">initState, types</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="built_in">Array</span>.isArray(types) ||</span><br><span class="line">    types.length !== <span class="number">3</span> ||</span><br><span class="line">    !types.every(<span class="function"><span class="params">type</span> =&gt;</span> <span class="keyword">typeof</span> type === <span class="string">'string'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected types to be an array of three string types.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [SOME_START, SOME_SUCCESS, SOME_FAILED] = types</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createReducer(initState, &#123;</span><br><span class="line">    [SOME_START](state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">isRequesting</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [SOME_SUCCESS](state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">data</span>: action.data, <span class="attr">isRequesting</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [SOME_FAILED](state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">errorMsg</span>: action.errMsg, <span class="attr">isRequesting</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其中的条件处理抽取出来，作为<code>createHandler</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createHandler = <span class="function"><span class="params">types</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="built_in">Array</span>.isArray(types) ||</span><br><span class="line">    types.length !== <span class="number">3</span> ||</span><br><span class="line">    !types.every(<span class="function"><span class="params">type</span> =&gt;</span> <span class="keyword">typeof</span> type === <span class="string">'string'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected types to be an array of three string types.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [SOME_START, SOME_SUCCESS, SOME_FAILED] = types</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [SOME_START](state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">isRequesting</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [SOME_SUCCESS](state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">data</span>: action.data, <span class="attr">isRequesting</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [SOME_FAILED](state, action) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">errorMsg</span>: action.errMsg, <span class="attr">isRequesting</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// options为另外的reducer处理逻辑</span></span><br><span class="line"><span class="keyword">const</span> createAsyncReducer = <span class="function">(<span class="params">initState, types, options = &#123;&#125;</span>) =&gt;</span></span><br><span class="line">  createReducer(initState, &#123;</span><br><span class="line">    ...createHandler(types),</span><br><span class="line">    ...options</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>完成这些工具函数之后，编写异步请求的 reducer 只需要像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步请求的reducer</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'../actionTypes'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">  isRequesting: <span class="literal">false</span>,</span><br><span class="line">  data: [],</span><br><span class="line">  errorMsg: <span class="string">''</span>,</span><br><span class="line">  otherValue: <span class="string">''</span> <span class="comment">// options要处理的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  [actionTypes.OTHER_ACTION]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> (&#123;</span><br><span class="line">    ...state,</span><br><span class="line">    otherValue: action.value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> types = [</span><br><span class="line">  actionTypes.SOME_START,</span><br><span class="line">  actionTypes.SOME_SUCCESS,</span><br><span class="line">  actionTypes.SOME_FAILED</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> someRequestReducer = createAsyncReducer(initState, types, options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在action/index.js里添加处理option的action</span></span><br><span class="line"><span class="keyword">const</span> otherAction = createAction(action.OTHER_ACTION, <span class="string">'value'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="以-axios-为基础再次扩展中间件"><a href="#以-axios-为基础再次扩展中间件" class="headerlink" title="以 axios 为基础再次扩展中间件"></a>以 axios 为基础再次扩展中间件</h2><p>如果使用 axios 来调用 AJAX，我们可以直接把 axios 写在中间件里，在编写异步 action 的时候添加 axios 的参数。</p>
<p>值得注意的是，在一个组件中调用 dispatch 时，我们往往会需要其他 reducer 的数据来作为参数，但我们又不需要使用这些数据来渲染组件，使用<code>getState</code>可以解决这个问题。</p>
<p>综合以上问题，再次扩展中间件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span> <span class="comment">// 引入axios库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; dispatch, getState &#125;) =&gt; <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// params为axios参数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; types, generateParams, callback = &#123;&#125; &#125; = action</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!types) &#123;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="built_in">Array</span>.isArray(types) ||</span><br><span class="line">    types.length !== <span class="number">3</span> ||</span><br><span class="line">    !types.every(<span class="function"><span class="params">type</span> =&gt;</span> <span class="keyword">typeof</span> type === <span class="string">'string'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected types to be an array of three string types.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> generateParams !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected generateParams to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected callback to be an object.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [startType, successType, failureType] = types</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    messageSuccess = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    messageFailed = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    callbackFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">    errorList = [],</span><br><span class="line">    handleData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  &#125; = callback</span><br><span class="line"></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: startType &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入getState作为参数</span></span><br><span class="line">  <span class="keyword">return</span> axios(generateParams(getState))</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; ErrCode, ErrMsg, data &#125; = response.data</span><br><span class="line">      <span class="keyword">const</span> error = errorList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.errorCode === ErrCode)[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">let</span> errorMsg = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        errorMsg = error.errorMsg</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ErrCode !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          dispatch(&#123; <span class="attr">type</span>: failureType, errorMsg &#125;)</span><br><span class="line">          <span class="keyword">return</span> errorMsg &amp;&amp; <span class="keyword">typeof</span> errorMsg === <span class="string">'string'</span></span><br><span class="line">            ? messageFailed(errorMsg)</span><br><span class="line">            : <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch(&#123; <span class="attr">type</span>: failureType, <span class="attr">errorMsg</span>: ErrMsg || <span class="string">'failed'</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span> messageFailed()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ErrCode === <span class="number">200</span>) &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">          type: successType,</span><br><span class="line">          data: handleData(data) || data</span><br><span class="line">        &#125;)</span><br><span class="line">        callbackFunc(dispatch, data, getState)</span><br><span class="line">        <span class="keyword">return</span> messageSuccess()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error)</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: failureType, <span class="attr">errorMsg</span>: <span class="string">'sometext'</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的 action：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; message &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messageCallback = &#123;</span><br><span class="line">  success: <span class="function"><span class="params">msg</span> =&gt;</span> message.success(msg),</span><br><span class="line">  failed: <span class="function"><span class="params">msg</span> =&gt;</span> message.failed(msg),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> someAction = <span class="function">(<span class="params">params</span>) =&gt;</span> (&#123;</span><br><span class="line">  types: [actionTypes.SOME_START, actionTypes.SOME_SUCCESS, actionTypes.SOME_FAILED],</span><br><span class="line">  <span class="comment">// 需要使用其他reducer，则使用getState</span></span><br><span class="line">  generateParams: <span class="function">(<span class="params">getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 否则直接省略参数，返回对象</span></span><br><span class="line">  generateParams: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  callback: &#123;</span><br><span class="line">    messageSuccess: <span class="function">(<span class="params">msg = '请求成功！'</span>) =&gt;</span> messageCallback.success(msg),</span><br><span class="line">    messageFailed: <span class="function">(<span class="params">msg = '请求失败！'</span>) =&gt;</span> messageCallback.failed(msg),</span><br><span class="line">    errorList: [&#123;</span><br><span class="line">      errorCode: <span class="number">1010</span>,</span><br><span class="line">      errorMsg: <span class="string">'登录状态失效'</span>,</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      errorCode: <span class="number">202</span>,</span><br><span class="line">      errorMsg: <span class="string">'信息重复'</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">    handleData: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    callbackFunc: <span class="function">(<span class="params">dispatch, data, getState</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 一些回调方法，如发起另外的action，data处理等</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最后要说的是，因为不同的项目有不同的需求，可能上面的工具函数无法与你当前的需求完全匹配，但是思想是一致的。因为 redux 的设计原则导致它容易编写出大量类似的代码，这时你可以考虑像上面一样，封装自己的工具函数。</p>
]]></content>
      <categories>
        <category>react</category>
        <category>redux</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传之验证后缀与内容是否一致</title>
    <url>/2019/01/04/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B9%8B%E9%AA%8C%E8%AF%81%E5%90%8E%E7%BC%80%E4%B8%8E%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<blockquote>
<p>在上传前验证，开发者们往往喜欢通过后缀或者<code>File.type()</code>去判断一个文件类型来决定是否符合上传要求。但这显然是不可靠的，当被别有用心的人利用后，就可能在服务器被执行。今天就来解决如何在前端验证文件内容跟后缀是否一致。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-Magic-number"><a href="#1-Magic-number" class="headerlink" title="1. Magic number"></a>1. Magic number</h2><p>既然要解析文件内容那这个 Magic Number 就很关键 =&gt; Magic number：即幻数，它可以用来标记文件或者协议的格式，很多文件都有幻数标志来表明该文件的格式。<br>以下是常见的文件头：<br>| 文件类型 | 文件头(16 进制) |<br>| ————————– | —————————- |<br>| JPEG (jpg) | FFD8FF |<br>| JPEG (jpg) | FFD8FF |<br>| PNG (png) | 89504E47 |<br>| GIF (gif) | 47494638 |<br>| TIFF (tif) | 49492A00 |<br>| Windows Bitmap (bmp) | 424D |<br>| CAD (dwg) | 41433130 |<br>| Adobe Photoshop (psd) | 38425053 |<br>| Rich Text Format (rtf) | 7B5C727466 |<br>| XML (xml) | 3C3F786D6C |<br>| HTML (html) | 68746D6C3E |<br>| Adobe Acrobat (pdf) | 255044462D312E |<br>| Email (eml) | 44656C69766572792D646174653A |<br>| Outlook Express (dbx) | CFAD12FEC5FD746F |<br>| Outlook (pst) | 2142444E |<br>| MS Word/Excel (xls.or.doc) | D0CF11E0 |<br>| MS Access (mdb) | 5374616E64617264204A |<br>| WordPerfect (wpd) | FF575043 |<br>| Postscript (eps.or.ps) | 252150532D41646F6265 |<br>| Quicken (qdf) | AC9EBD8F |<br>| Windows Password (pwl) | E3828596 |<br>| ZIP Archive (zip) | 504B0304 |<br>| RAR Archive (rar) | 52617221 |<br>| Wave (wav) | 57415645 |<br>| AVI (avi) | 41564920 |<br>| Real Audio (ram) | 2E7261FD |<br>| Real Media (rm) | 2E524D46 |<br>| MPEG (mpg) | 000001BA |<br>| MPEG (mpg) | 000001B3 |<br>| Quicktime (mov) | 6D6F6F76 |<br>| Windows Media (asf) | 3026B2758E66CF11 |<br>| MIDI (mid) | 4D546864 |</p>
<h2 id="2-解析文件"><a href="#2-解析文件" class="headerlink" title="2. 解析文件"></a>2. 解析文件</h2><p>通常上传文件我们都会获取<code>File</code>形式的文件；<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/FileReader" target="_blank" rel="noopener">FileReader 文档</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 使用FileReader以ArrayBuffer的形式读取数据</span></span><br><span class="line"><span class="comment">// 2. 使用Uint8Array换取文件头，看截取前面几位就看具体需要了</span></span><br><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">reader.onload = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(evt.target.result.slice(<span class="number">0</span>, <span class="number">6</span>))</span><br><span class="line">  <span class="comment">// 将截取的result和magic number比较</span></span><br><span class="line">&#125;</span><br><span class="line">reader.readAsArrayBuffer(file)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>file upload</tag>
      </tags>
  </entry>
  <entry>
    <title>dva源码解析</title>
    <url>/2019/04/12/dva%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20copy/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>沿着旧地图，永远找不到新大陆。</p>
</blockquote>
<p>=&gt; 就 spa 应用而言，我觉得 dva 是我见到过结构还算舒服的 react 全家桶框架</p>
<p>DVA 优势(结构就以 dva-cli 初始项目结构来展开)</p>
<ol>
<li>它尽可能推荐前端去使用<strong>纯函数组件</strong>，对于页面切换可以由地址栏监听实现<code>history.listen</code></li>
<li><strong>层次清晰</strong> 主要分为展示层（routes）+ 容器层（models）+ 服务调用（services），入口是 src/index.js</li>
<li>reducer 即 model 层使用 <code>duck</code> 模型，又有自己的命名空间（nameSpace），使得模块代码编写不用像传统分文件编写 action types reducer</li>
<li>对 reducer 封装了拓展（model-extend），可加入通用的 reducer 如改变状态的 action 和分页 reducer 模型；</li>
<li>使用 nameSpace 唯一标识模块;</li>
<li>…更多“吹牛逼现场”请前往<a href="https://dvajs.com/" target="_blank" rel="noopener">dva 官网</a>观看</li>
</ol>
<a id="more"></a>
<h2 id="1-第一步：初始化-gt-const-app-dva-opt"><a href="#1-第一步：初始化-gt-const-app-dva-opt" class="headerlink" title="1.第一步：初始化 =&gt;const app = dva(opt)"></a>1.第一步：初始化 =&gt;<code>const app = dva(opt)</code></h2><ul>
<li>首先说明下常用 opt 配置 (更多看下文 hooks 理论上都可配置)</li>
</ul>
<ol>
<li>可以挂载组件：</li>
<li>可以修改路由模式：默认 <code>hashHistory</code></li>
<li><p>全局的<code>onError (error) {// 处理全局error}</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dva <span class="keyword">from</span> <span class="string">'dva'</span></span><br><span class="line"><span class="keyword">import</span> createHistory <span class="keyword">from</span> <span class="string">'history/createBrowserHistory'</span></span><br><span class="line"><span class="keyword">import</span> createLoading <span class="keyword">from</span> <span class="string">'dva-loading'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = dva(&#123;</span><br><span class="line">  ...createLoading(&#123; <span class="attr">effects</span>: <span class="literal">true</span> &#125;), <span class="comment">// 1</span></span><br><span class="line">  history: createHistory(), <span class="comment">// 2</span></span><br><span class="line">  onError(error) &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 处理全局error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>源码中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// history 配置，默认 hashHistory</span></span><br><span class="line"><span class="keyword">const</span> history = opts.history || createHashHistory()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个先不管 看到用到createOpts的地方</span></span><br><span class="line"><span class="keyword">const</span> createOpts = &#123;</span><br><span class="line">  initialReducer: &#123;</span><br><span class="line">    routing</span><br><span class="line">  &#125;,</span><br><span class="line">  setupMiddlewares(middlewares) &#123;</span><br><span class="line">    <span class="keyword">return</span> [routerMiddleware(history), ...middlewares]</span><br><span class="line">  &#125;,</span><br><span class="line">  setupApp(app) &#123;</span><br><span class="line">    app._history = patchHistory(history)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里使用了“dva-core”里面的create方法</span></span><br><span class="line"><span class="keyword">const</span> app = core.create(opts, createOpts)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  其实是返回了这么一个对象=&gt;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        _models, // 存放 model 对象组</span></span><br><span class="line"><span class="comment">        _store, // 初始为 null</span></span><br><span class="line"><span class="comment">        _plugin, // plugin构造函数内容 hooks被作为属性存在这里(见附录)</span></span><br><span class="line"><span class="comment">        use, // plugin的use方法</span></span><br><span class="line"><span class="comment">        model, // 注册model方法=》检测model合法性 + 添加命名空间 + 存入app._models</span></span><br><span class="line"><span class="comment">        start // 启动方法 =》 全局错误处理 + 注册plugin + 创建store</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接下来</span></span><br><span class="line"><span class="keyword">const</span> oldAppStart = app.start</span><br><span class="line">app.router = router <span class="comment">// 把router 存入app._router</span></span><br><span class="line">app.start = start <span class="comment">// 检测容器 + 执行oldAppStart + 开启热加载 + 渲染</span></span><br></pre></td></tr></table></figure>
<p>附录：hooks</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">  onError: [],</span><br><span class="line">  onStateChange: [],</span><br><span class="line">  onAction: [],</span><br><span class="line">  onHmr: [],</span><br><span class="line">  onReducer: [],</span><br><span class="line">  onEffect: [],</span><br><span class="line">  extraReducers: [],</span><br><span class="line">  extraEnhancers: [],</span><br><span class="line">  _handleActions: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title>滚动加载--优化滚动性能</title>
    <url>/2019/01/20/%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD--%E4%BC%98%E5%8C%96%E6%BB%9A%E5%8A%A8%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<blockquote>
<p>亲爱的儿子，我还没有追到你娘，提前祝你新年快乐！爸爸明年会努力的~</p>
</blockquote>
<p><img src="/images/hello.jpg" alt="hello~"></p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>最近有用<a href="https://github.com/aliyun-UED/aliyun-sdk-js" target="_blank" rel="noopener">阿里云 sdk</a> 中的<a href="https://help.aliyun.com/document_detail/29007.html" target="_blank" rel="noopener">日志服务</a>,在它的 api 里发现它并不支持分页查询，倒是有个 offset 指定日志起点,所以需要配合鼠标滚动做一个懒加载。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>最容易想到的就是做一个底部检测，当用户滚动到底部时再请求下一部分内容，并将结果拼接到上一次结果之后。</li>
<li>但很多情况下返回内容不只有字符，还有媒体文件，这个时候浏览器的下载通道很容易被占满。这个时候 我们实际需要的其实是用户看得到的内容去做加载就可以，用户看不到的可以先用墓碑（占位符）。这么做可以大大减少流量浪费~</li>
<li>理清思路后大致实现不难，不过滚动是个高频发事件，这在一些极端 case 下容易引起卡顿，需要进行优化，这也是本文重点。</li>
</ol>
<h2 id="优化滚动"><a href="#优化滚动" class="headerlink" title="优化滚动"></a>优化滚动</h2><ul>
<li>常用两种优化方式</li>
</ul>
<ol>
<li><code>Throttle</code>: 允许我们限制激活响应的数量。通过限制每秒回调的数量的方式来达到优化目的;</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const fn = throttle(e =&gt; console.log(e, "123"), 300)</span></span><br><span class="line"><span class="comment">// const scroll = listen(document.body, "mousewheel", fn)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">...props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [fn, threshhold = <span class="number">250</span>, scope] = props</span><br><span class="line">  <span class="keyword">let</span> last</span><br><span class="line">  <span class="keyword">let</span> deferTimer</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> context = scope || <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">if</span> (last &amp;&amp; now &lt; last + threshhold) &#123;</span><br><span class="line">      clearTimeout(deferTimer)</span><br><span class="line">      deferTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 停止滚动延迟后触发</span></span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, [event, ...props])</span><br><span class="line">      &#125;, threshhold)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      last = now</span><br><span class="line">      fn.apply(context, [event, ...props])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>Debounce</code>: 事件发生时，不会立即激活回调。而是等待一定的时间并检查相同的事件是否再次触发。如果是，我们重置定时器，并再次等待。如果在等待期间没有发生相同的事件，我们就立即激活回调。 =&gt; 使用于滚动结束后执行操作</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本防抖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">...props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [action, wait = <span class="number">200</span>] = props</span><br><span class="line">  <span class="keyword">let</span> last</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span></span><br><span class="line">    clearTimeout(last)</span><br><span class="line">    last = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      action.apply(ctx, [event, ...props])</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>lodash 实现</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject, isFn &#125; <span class="keyword">from</span> <span class="string">"./is"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 截流函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">fn</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>[wait=250]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> <span class="variable">options</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait = <span class="number">250</span>, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> leading = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">    leading = <span class="string">"leading"</span> <span class="keyword">in</span> options ? !!options.leading : leading</span><br><span class="line">    trailing = <span class="string">"trailing"</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">    leading,</span><br><span class="line">    trailing,</span><br><span class="line">    maxWait: wait</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">func</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">wait</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> <span class="variable">options</span></span></span></span><br><span class="line"><span class="comment"> *    - leading:Boolean 开始时调用</span></span><br><span class="line"><span class="comment"> *    - trailing:Boolean 结束时调用</span></span><br><span class="line"><span class="comment"> *    - maxWait:Number 最大等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastArgs, lastThis, maxWait, result, timerId, lastCallTime</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> leading = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> maxing = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> isBrowser = <span class="keyword">typeof</span> <span class="built_in">window</span> == <span class="string">"object"</span> &amp;&amp; <span class="built_in">window</span> !== <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> useRAF =</span><br><span class="line">    !wait &amp;&amp;</span><br><span class="line">    wait !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">    isBrowser &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">window</span>.requestAnimationFrame === <span class="string">"function"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isFn(func)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Expected a function"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  wait = +wait || <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">    leading = !!options.leading</span><br><span class="line">    maxing = <span class="string">"maxWait"</span> <span class="keyword">in</span> options</span><br><span class="line">    maxWait = maxing ? <span class="built_in">Math</span>.max(+options.maxWait || <span class="number">0</span>, wait) : maxWait</span><br><span class="line">    trailing = <span class="string">"trailing"</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = lastArgs</span><br><span class="line">    <span class="keyword">const</span> thisArg = lastThis</span><br><span class="line"></span><br><span class="line">    lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">    lastInvokeTime = time</span><br><span class="line">    result = func.apply(thisArg, args)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">startTimer</span>(<span class="params">pendingFunc, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">      <span class="built_in">window</span>.cancelAnimationFrame(timerId)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>.requestAnimationFrame(pendingFunc)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setTimeout(pendingFunc, wait)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cancelTimer</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>.cancelAnimationFrame(id)</span><br><span class="line">    &#125;</span><br><span class="line">    clearTimeout(id)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">leadingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    lastInvokeTime = time</span><br><span class="line">    timerId = startTimer(timerExpired, wait)</span><br><span class="line">    <span class="keyword">return</span> leading ? invokeFunc(time) : result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">remainingWait</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line">    <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxing</span><br><span class="line">      ? <span class="built_in">Math</span>.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class="line">      : timeWaiting</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">shouldInvoke</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">    <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次调用 || 上一次已经停止 || 系统时间倒退 || 已经达到max限制</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      lastCallTime === <span class="literal">undefined</span> ||</span><br><span class="line">      timeSinceLastCall &gt;= wait ||</span><br><span class="line">      timeSinceLastCall &lt; <span class="number">0</span> ||</span><br><span class="line">      (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">timerExpired</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">if</span> (shouldInvoke(time)) &#123;</span><br><span class="line">      <span class="comment">// 在 trailing edge 且时间符合条件时，调用 trailingEdge函数，否则重启定时器</span></span><br><span class="line">      <span class="keyword">return</span> trailingEdge(time)</span><br><span class="line">    &#125;</span><br><span class="line">    timerId = startTimer(timerExpired, remainingWait(time))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">trailingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    timerId = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">      <span class="keyword">return</span> invokeFunc(time)</span><br><span class="line">    &#125;</span><br><span class="line">    lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timerId !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      cancelTimer(timerId)</span><br><span class="line">    &#125;</span><br><span class="line">    lastInvokeTime = <span class="number">0</span></span><br><span class="line">    lastArgs = lastCallTime = lastThis = timerId = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">flush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerId === <span class="literal">undefined</span> ? result : trailingEdge(<span class="built_in">Date</span>.now())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pending</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerId !== <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">const</span> isInvoking = shouldInvoke(time)</span><br><span class="line"></span><br><span class="line">    lastArgs = args</span><br><span class="line">    lastThis = <span class="keyword">this</span></span><br><span class="line">    lastCallTime = time</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leadingEdge(lastCallTime)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxing) &#123;</span><br><span class="line">        timerId = startTimer(timerExpired, wait)</span><br><span class="line">        <span class="keyword">return</span> invokeFunc(lastCallTime)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      timerId = startTimer(timerExpired, wait)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  debounced.cancel = cancel</span><br><span class="line">  debounced.flush = flush</span><br><span class="line">  debounced.pending = pending</span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; throttle, debounce &#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断到达底部"><a href="#判断到达底部" class="headerlink" title="判断到达底部"></a>判断到达底部</h2><ul>
<li>scrollHeight &lt;=&gt; scrollTop + offsetHeight<br>对于预加载可以适当加个预加载高度 这样提前加载会更加流畅</li>
</ul>
<h2 id="dom-回收"><a href="#dom-回收" class="headerlink" title="dom 回收"></a>dom 回收</h2><p>由于每一个节点都会增加一些额外的内存、布局、样式和绘制。进行 DOM 回收可以使 dom 保持在一个比较低的数量上，进而加快上面提到的这些处理过程。在 dom 移除页面一定高度后对节点进行 <code>move()</code> 操作。为了保证滚动条的正确比例和防止高度塌陷，需要显示的声明高度。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>addEventListener</tag>
        <tag>mouseWheel</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Proxy实现双向绑定</title>
    <url>/2019/08/10/%E4%BD%BF%E7%94%A8proxy%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>技术从来不会受限于语言，受限你的，永远只是思想。（博主发现了一个有意思的机器学习库，TensorFlow 的 js 版本，有兴趣的同学可以看一下<a href="https://www.tensorflow.org/api_docs）" target="_blank" rel="noopener">https://www.tensorflow.org/api_docs）</a></p>
</blockquote>
<p>=&gt; 这里以<code>Proxy</code>为例来进行编码,当然,我们需要事先了解一下<a href="https://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">Proxy</a>的使用方法.</p>
<p><code>Proxy</code>就像一个代理器,当有人对目标对象进行处理(set、has、get 等等操作)的时候它会首先经过它，这时我们可以使用代码进行处理，此时<code>Proxy</code>相当于一个中介或者叫代理人,它经常被用于代理模式中,可以做字段验证、缓存代理、访问控制等等。</p>
<a id="more"></a>
<h2 id="1-Object-defineProperty"><a href="#1-Object-defineProperty" class="headerlink" title="1.Object.defineProperty"></a>1.<code>Object.defineProperty</code></h2><p>众所周知，<code>vue</code>使用了<code>Object.defineProperty</code>来做数据劫持，它是利用劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子：对对象属性a的拦截</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get val'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set val:'</span> + newVal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="2-与Object-defineProperty相比，Proxy的优势"><a href="#2-与Object-defineProperty相比，Proxy的优势" class="headerlink" title="2.与Object.defineProperty相比，Proxy的优势"></a>2.与<code>Object.defineProperty</code>相比，<code>Proxy</code>的优势</h2><ol>
<li><p>数组作为特殊的对象，但<code>Object.defineProperty</code>无法监听数组变化。</p>
</li>
<li><p><code>Object.defineProperty</code>只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</p>
</li>
<li><p>Proxy 有多达 13 种拦截方法,不限于<code>apply、ownKeys、deleteProperty、has</code>等等是<code>Object.defineProperty</code>不具备的。</p>
</li>
<li><p><code>Proxy</code>返回的是一个新对象,我们可以只操作新的对象达到目的,而<code>Object.defineProperty</code>只能遍历对象属性直接修改</p>
</li>
<li><p><code>Proxy</code>作为新标准将受到浏览器厂商重点持续的性能优化</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Vue主要有两个方法</span></span><br><span class="line"><span class="comment"> * $proxy: 把输入对象属性代理到vue实例上</span></span><br><span class="line"><span class="comment"> * $watch: 监听对象的变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$data = data</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>.$proxy(key))</span><br><span class="line">  &#125;</span><br><span class="line">  $watch(key, cb) &#123;</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>, key, cb)</span><br><span class="line">  &#125;</span><br><span class="line">  $proxy(key) &#123;</span><br><span class="line">    <span class="built_in">Reflect</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>: () =&gt; this.$data[key],</span><br><span class="line">      <span class="keyword">set</span>: val =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>._data[key] = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Watcher</span></span><br><span class="line"><span class="comment"> * 监听数据变化，并通知变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, key, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm <span class="comment">// vue实例</span></span><br><span class="line">    <span class="keyword">this</span>.callback = callback <span class="comment">// 回调：返回更新</span></span><br><span class="line">    <span class="keyword">this</span>.key = key <span class="comment">// 被订阅的数据</span></span><br><span class="line">    <span class="keyword">this</span>.val = <span class="keyword">this</span>.get() <span class="comment">// 维护更新之前的数据</span></span><br><span class="line">    vm.$data = <span class="keyword">this</span>.createProxy(vm.$data) <span class="comment">// 为数据做代理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update(newVal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callback(newVal)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  createProxy(data) &#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">      <span class="keyword">get</span>(target, property) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(target, property, value) &#123;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span> (target[property] != value) &#123;</span><br><span class="line">          <span class="keyword">const</span> isOk = <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">          <span class="keyword">if</span> (_this.key === property) &#123;</span><br><span class="line">            <span class="comment">// 同一层级</span></span><br><span class="line">            res = value</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = _this.get()</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">          &#125;</span><br><span class="line">          _this.callback(res)</span><br><span class="line">          <span class="keyword">return</span> isOk</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toDeepProxy(data, handler)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">toDeepProxy</span>(<span class="params">object, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isPureObject(object)) addSubProxy(object, handler)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(object, handler)</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">addSubProxy</span>(<span class="params">object, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> object) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> object[prop] == <span class="string">'object'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isPureObject(object[prop])) addSubProxy(object[prop], handler)</span><br><span class="line">            object[prop] = <span class="keyword">new</span> <span class="built_in">Proxy</span>(object[prop], handler)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        object = <span class="keyword">new</span> <span class="built_in">Proxy</span>(object, handler)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">isPureObject</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> object !== <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> object) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> object[prop] == <span class="string">'object'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向绑定的完整例子已放在 <a href="https://codepen.io/zhaozeqing/pen/VoXjvy" target="_blank" rel="noopener">codepen</a> 上</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>AST--使用编译的方式修改代码！</title>
    <url>/2019/12/12/AST--%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>最近有一个面板搭建的需求，环境为 react，而现有面板组件为 vue。<br>就有了现在这个转换需求~<br>AST(抽象语法树)：顾名思义，它把代码拆解成了树的形式。<br>接下来我会以代码增删改查的形式带大家初步了解”代码编辑”！</p>
<blockquote>
<ul>
<li>查：先看再用！(为什么加后缀，因为觉得内容不够丰满)</li>
<li>增：无中生有！(为什么加后缀，因为觉得内容不够丰满)</li>
<li>删：罢黜百家！(为什么加后缀，因为觉得内容不够丰满)</li>
<li>改：偷天换日！(为什么加后缀，因为觉得内容不够丰满)</li>
<li>如果你正有 vue-to-react 需求，那么这是我想说的</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="一、查：先看再用"><a href="#一、查：先看再用" class="headerlink" title="一、查：先看再用"></a>一、查：先看再用</h2><p>我保证要是没有它，你会很痛苦 <a href="https://astexplorer.net/" target="_blank" rel="noopener">ast explorer</a></p>
<p>我们以 js 代码为例：</p>
<ol>
<li>打开必需品：ast explorer</li>
<li>选择 JavaScript 和 babylon7</li>
<li>输入<code>const a = 1 + 1</code></li>
<li>右边就会有代码树</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A[const a = 1 + 1]</span><br><span class="line">A --&gt; |kind|B[const]</span><br><span class="line">A --&gt; |declarations|C[a = 1 + 1]</span><br><span class="line">C --&gt;|Identifier| D[a]</span><br><span class="line">C --&gt;|BinaryExpression| E[1 + 1]</span><br><span class="line">E --&gt;|left| F[1]</span><br><span class="line">E --&gt;|operator| G[+]</span><br><span class="line">E --&gt;|right| H[1]</span><br></pre></td></tr></table></figure>
<p><img src="/images/ast_code.jpg" alt="ast_code"><br>也就是拆解到拆不了为止，我们需要的其实就是它的 type 以及值而已，type 就是定义这个数据是什么类型的东西，分了很多类，我们可以在 <a href="https://babeljs.io/docs/en/babel-types" target="_blank" rel="noopener">@babel/types</a> 找到相应的 type。<br>path.skip() 执行之后，就不会在对叶节点进行遍历<br>path.stop() 执行之后，就会去下次遍历</p>
<h2 id="二、增：无中生有！"><a href="#二、增：无中生有！" class="headerlink" title="二、增：无中生有！"></a>二、增：无中生有！</h2><blockquote>
<p>现在咋们就来把 <code>const a = 1 + 1</code> 生成出来！为了让新手也能一起动手操练起来，咱们就从新建项目开始。</p>
</blockquote>
<ol>
<li>首先我们要创建项目文件夹</li>
<li>快速创建 package.json<code>$ npm init -yes</code></li>
<li>下载依赖 : <code>npm install @babel/parser @babel/types @babel/generator @babel/traverse</code></li>
</ol>
<ul>
<li>@babel/parser =&gt; 字符串代码解析成语法树</li>
<li>@babel/types =&gt; 用来生成和检测数据类型</li>
<li>@babel/generator =&gt; 语法树转成代码字符串</li>
<li>@babel/traverse =&gt; 这次没用到 用来访问语法树，可以在里面进行节点删改</li>
</ul>
<ol start="4">
<li>项目下创建 index.js</li>
<li>写入:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parse = <span class="built_in">require</span>(<span class="string">"@babel/parser"</span>).parse</span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">"@babel/types"</span>)</span><br><span class="line"><span class="keyword">const</span> generate = <span class="built_in">require</span>(<span class="string">"@babel/generator"</span>).default</span><br><span class="line"><span class="comment">// const traverse = require('@babel/traverse').default</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">""</span></span><br><span class="line"><span class="keyword">const</span> ast = parse(code)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 便于理解我一步步拆解，这个其实就是拆解代码的逆过程</span></span><br><span class="line"><span class="comment"> * 刚接触的话可以根据ast explore中生成的语法树中的type,</span></span><br><span class="line"><span class="comment"> * 去到<span class="doctag">@babel</span>/type中查找相应type,会有相应的方法和入参说明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.生成数字 1</span></span><br><span class="line"><span class="keyword">const</span> number = t.numericLiteral(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 2.生成二元表达式 1 + 1</span></span><br><span class="line"><span class="keyword">const</span> exp = t.binaryExpression(<span class="string">"+"</span>, number, number)</span><br><span class="line"><span class="comment">// 3.生成变量 a</span></span><br><span class="line"><span class="keyword">const</span> varible = t.identifier(<span class="string">"a"</span>)</span><br><span class="line"><span class="comment">// 4.生成变量声明 a = 1 + 1</span></span><br><span class="line"><span class="keyword">const</span> declarations = t.variableDeclarator(varible, exp)</span><br><span class="line"><span class="comment">// 5.生成变量声明 const a = 1 + 1</span></span><br><span class="line"><span class="keyword">const</span> content = t.variableDeclaration(<span class="string">"const"</span>, [declarations])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内容放入body中</span></span><br><span class="line">ast.program.body.push(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = generate(ast, &#123; <span class="attr">quotes</span>: <span class="string">"single"</span>, <span class="attr">retainLines</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(output.code) <span class="comment">// const a = 1 + 1</span></span><br></pre></td></tr></table></figure>
<h2 id="三、删改：为什么放一起，因为改其实就是先删后增"><a href="#三、删改：为什么放一起，因为改其实就是先删后增" class="headerlink" title="三、删改：为什么放一起，因为改其实就是先删后增"></a>三、删改：为什么放一起，因为改其实就是先删后增</h2><ol>
<li>替换： <code>replaceWith()</code> <code>replaceWithSourceString()</code><br>我们把<code>const a = 1 + 1</code> 改为 <code>1 * 1</code>，这个时候<code>traverse</code>就用上了<br>咱们把之前生成的<code>ast</code>放进来</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">traverse(ast, &#123;</span><br><span class="line">  <span class="comment">// 使用相应type来快速访问节点，这里快速来到二元表达式节点，即 1 + 1</span></span><br><span class="line">  <span class="comment">// 并使用path.replaceWith() 将节点 1 + 1替换</span></span><br><span class="line">  BinaryExpression(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.node.operator === <span class="string">"+"</span>) &#123;</span><br><span class="line">      path.replaceWith(t.binaryExpression(<span class="string">"*"</span>, path.node.left, path.node.right))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips：对于简单的静态节点还可以直接使用<strong>path.replaceWithSourceString(‘a*b’)</strong>来达到目的!!!</p>
</blockquote>
<ol start="2">
<li>插入操作： <code>pushContainer</code>、<code>unshiftContainer</code>、<code>insertBefore</code>、<code>insertAfter</code></li>
</ol>
<ul>
<li>pushContainer：针对子节点为数组时，为数组 push 一个 node</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">       const obj = &#123;</span></span><br><span class="line"><span class="string">           a: 'a',</span></span><br><span class="line"><span class="string">           b: 'b'</span></span><br><span class="line"><span class="string">       &#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = parse(code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> property = t.objectProperty(t.identifier(<span class="string">"c"</span>), t.stringLiteral(<span class="string">"c"</span>))</span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  ObjectExpression(path) &#123;</span><br><span class="line">    path.pushContainer(<span class="string">"properties"</span>, property)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>unshiftContainer： 与 pushContainer 对应 =》 unshift</li>
<li>insertAfter 兄弟节点的插入操作</li>
</ul>
<ol start="3">
<li>删除节点 path.remove()</li>
</ol>
<h2 id="四、vue-to-react"><a href="#四、vue-to-react" class="headerlink" title="四、vue-to-react"></a>四、vue-to-react</h2><p>vue 有 template、script、style 三部分<br>本人的方案：<br>style 根据 lang 生成 对应 style 文件在 react 文件直接引用<br>script 解析成使用@babel/parser 生成 ast，操作 ast<br>template 使用 vue-template-compiler 插件解析，生成 ast,根据 vue 语法树来生成 render 代码<br>npm 包地址 <a href="https://www.npmjs.com/package/vue-to-react-tool" target="_blank" rel="noopener">vue-to-react-tool</a><br>本人目前实现的是</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 研究 vue 组件转 react<pre><code>目前已成功转换
</code></pre></li>
<li style="list-style: none"><input type="checkbox" checked> v-if、v-else-if、v-else</li>
<li style="list-style: none"><input type="checkbox" checked> v-for</li>
<li style="list-style: none"><input type="checkbox" checked> v-show</li>
<li style="list-style: none"><input type="checkbox" checked> v-bind v-bind:attr.sync = xxx&gt; // 双向绑定的特殊情况   v-bind:attr=xxx  v-on:emiterName ==&gt; emiterName={(new) =&gt; this.setState({xxx:new})</li>
<li style="list-style: none"><input type="checkbox" checked> v-model:与 v-bind:attr.sync 类似</li>
<li style="list-style: none"><input type="checkbox" checked> v-on</li>
<li style="list-style: none"><input type="checkbox" checked> v-text <span v-text="msg"></span> =》<span></span></li>
<li style="list-style: none"><input type="checkbox" checked> v-html =&gt; dangerousHtml</li>
<li style="list-style: none"><input type="checkbox" checked> class =&gt; className (考虑 class v-bind:class 同时存在的情况)</li>
<li style="list-style: none"><input type="checkbox" checked> data() =&gt; this.state</li>
<li style="list-style: none"><input type="checkbox" checked> Props =&gt; props</li>
<li style="list-style: none"><input type="checkbox" checked>  =&gt; { expression }</li>
<li style="list-style: none"><input type="checkbox" checked> 组件名转驼峰</li>
<li style="list-style: none"><input type="checkbox" checked> created: ‘componentWillMount’,</li>
<li style="list-style: none"><input type="checkbox" checked> mounted: ‘componentDidMount’,</li>
<li style="list-style: none"><input type="checkbox" checked> updated: ‘componentDidUpdate’,</li>
<li style="list-style: none"><input type="checkbox" checked> beforeDestroy: ‘componentWillUnmount’,</li>
<li style="list-style: none"><input type="checkbox" checked> errorCaptured: ‘componentDidCatch’,</li>
<li style="list-style: none"><input type="checkbox" checked> template =&gt;  render</li>
<li style="list-style: none"><input type="checkbox" checked> style =&gt; index.(css | stylus | sass | less) (目前考虑)</li>
<li style="list-style: none"><input type="checkbox" checked> 移除 ts type 功能</li>
<li style="list-style: none"><input type="checkbox" checked> this.\$refs</li>
<li style="list-style: none"><input type="checkbox" checked> V-for V-if v-show 同时存在的情况</li>
</ul>
<p>仍需要处理</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 事件修饰符：</li>
</ul>
<ul>
<li>.stop</li>
<li>.prevent</li>
<li>.capture</li>
<li>.self</li>
<li>.once</li>
<li>.passive</li>
</ul>
<ul>
<li style="list-style: none"><input type="checkbox"> v-on:attr = handle =&gt; v-on 暂不支持模板字符串型表达式</li>
<li style="list-style: none"><input type="checkbox"> v-bind.sync=”doc” =&gt; 暂不支持用对象设置多个 props</li>
<li style="list-style: none"><input type="checkbox"> watch</li>
<li style="list-style: none"><input type="checkbox"> Vux / vue-router(目前需求是组件、模块的转换，无需，看后续需求在考虑)</li>
<li style="list-style: none"><input type="checkbox"> 。。。</li>
</ul>
<p>目前是对我们的一个 vue 组件库进行转换，不过实际的代码情况会更加复杂，开发同学的编码习惯差别也很大，还需要针对各种情况详细处理。同时此方案也可以运用于小程序代码互转等场景中，所以我认为学写一下还是不错的，对代码编译的过程能更加深入了解</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>node</tag>
        <tag>react</tag>
        <tag>ast</tag>
      </tags>
  </entry>
</search>
