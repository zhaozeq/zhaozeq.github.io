<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.png?v=5.1.4" color="#222">





  <meta name="keywords" content="javascript,">





  <link rel="alternate" href="/atom.xml" title="Z_S" type="application/atom+xml">






<meta name="description" content="一、 变量赋值与解构 默认值赋值注意点：  只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null  默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = [];     // x=1; y=1let">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6">
<meta property="og:url" content="./2018/08/10/ES6/index.html">
<meta property="og:site_name" content="Z_S">
<meta property="og:description" content="一、 变量赋值与解构 默认值赋值注意点：  只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null  默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = [];     // x=1; y=1let">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-17T10:40:20.079Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6">
<meta name="twitter:description" content="一、 变量赋值与解构 默认值赋值注意点：  只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null  默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = [];     // x=1; y=1let">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="./2018/08/10/ES6/">





  <title>ES6 | Z_S</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Z_S</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">赵泽清 -- 一个追逐太阳的程序猿</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-概况">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            概况
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于我">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于我
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="./2018/08/10/ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵泽清">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z_S">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">ES6</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-10T00:00:00+08:00">
                2018-08-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-11-17T18:40:20+08:00">
                2018-11-17
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="一、-变量赋值与解构"><a href="#一、-变量赋值与解构" class="headerlink" title="一、 变量赋值与解构"></a>一、 变量赋值与解构</h3><ol>
<li><p>默认值赋值注意点：</p>
<ul>
<li><p>只有当一个数组成员严格等于undefined，默认值才会生效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line">let [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line">let [x = y, y = 1] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><br></p>
<a id="more"></a>
<ol start="2">
<li><p>变量的解构注意点：</p>
<ul>
<li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line">let &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">first // 1</span><br><span class="line">last // 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123; prop: x &#125; = undefined; // TypeError</span><br><span class="line">let &#123; prop: y &#125; = null; // TypeError</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了区分模式，还是表达式 –&gt; 只要有可能导致解构的歧义，就不得使用圆括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//变量申明</span><br><span class="line">let [(a)] = [1];</span><br><span class="line">let &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 函数参数</span><br><span class="line">function f([(z)]) &#123; return z; &#125;</span><br><span class="line">function f([z,(x)]) &#123; return x; &#125;</span><br><span class="line"></span><br><span class="line">//赋值语句的模式部分</span><br><span class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</span><br><span class="line">([a]) = [5];</span><br><span class="line"></span><br><span class="line">//可以使用（赋值语句的非模式部分）</span><br><span class="line">[(b)] = [3]; // 正确</span><br><span class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</span><br><span class="line">[(parseInt.prop)] = [3]; // 正确</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>&gt; 与`for...of`配合 获取键名和键值就非常方便。
</code></pre><p><br>  </p>
<h3 id="二、-字符串拓展"><a href="#二、-字符串拓展" class="headerlink" title="二、- 字符串拓展"></a>二、- 字符串拓展</h3><ol>
<li>详见<a href="http://es6.ruanyifeng.com/#docs/string" target="_blank" rel="noopener">阮一峰老师网站-String</a> </li>
</ol>
<p><br><br></p>
<h3 id="三、-正则拓展"><a href="#三、-正则拓展" class="headerlink" title="三、- 正则拓展"></a>三、- 正则拓展</h3><ol>
<li><p>详见<a href="http://es6.ruanyifeng.com/#docs/regex" target="_blank" rel="noopener">阮一峰老师网站-RegExp</a></p>
<ul>
<li>u修饰符，含义为“Unicode 模式”</li>
<li>y 修饰符“粘连”（sticky）修饰符：确保匹配必须从剩余的第一个位置开始</li>
<li><p>‘后行断言’</p>
<ul>
<li>先行断言：<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code><br>比如：只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code></li>
<li><p>先行否定断言：<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code></p>
</li>
<li><p>后行断言：<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code><br>如：只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code></p>
</li>
<li>后行否定断言：<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code><blockquote>
<p>后行断言与正常情况顺序是相反的，为“先右后左”的执行顺序</p>
</blockquote>
</li>
</ul>
</li>
<li><p>具名组匹配：允许为每一个组匹配指定一个名字；<br>引用某个“具名组匹配” <code>\k&lt;组名&gt;</code>或者<code>\1</code><br>具名组匹配在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（<code>?&lt;year&gt;</code>），然后就可以在exec方法返回结果的groups属性上引用该组名。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const REG = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/;</span><br><span class="line">REG.test(&apos;abc!abc!abc&apos;) // true</span><br><span class="line">REG.test(&apos;abc!abc!ab&apos;) // false</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h3 id="四、-数值的拓展"><a href="#四、-数值的拓展" class="headerlink" title="四、- 数值的拓展"></a>四、- 数值的拓展</h3><ol>
<li>二进制和八进制表示法(前缀<code>0b | 0o</code>)</li>
<li>Number.isFinite(), Number.isNaN()</li>
<li>Number.parseInt(), Number.parseFloat()</li>
<li>Number.isInteger()</li>
<li>Number.EPSILON(最小精度) <code>2 ** -52</code> </li>
<li>安全整数和 Number.isSafeInteger()：  判断是否在安全值范围</li>
<li>Math 对象的扩展</li>
<li>指数运算符<code>**</code></li>
</ol>
<p><br><br></p>
<h3 id="五、-函数的扩展"><a href="#五、-函数的扩展" class="headerlink" title="五、- 函数的扩展"></a>五、- 函数的扩展</h3><ol>
<li>函数参数的默认值</li>
<li>rest 参数 …props</li>
<li>严格模式</li>
<li>name 属性</li>
<li><p>箭头函数 =&gt;this引用的外层函数<br>注意点：</p>
<ul>
<li>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>
</li>
<li><p>双冒号运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> foo::bar;</span><br><span class="line"> // 等同于</span><br><span class="line"> bar.bind(foo);</span><br><span class="line"> </span><br><span class="line"> var method = obj::obj.foo;</span><br><span class="line">// 等同于</span><br><span class="line">var method = ::obj.foo;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾调用:(指某个函数的最后一步是调用另一个函数)优化</p>
<ul>
<li>只保留内层调用<blockquote>
<p>注意点：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>尾递归:尾调用自身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</span><br><span class="line"> function factorial(n) &#123;</span><br><span class="line">    if (n === 1) return 1;</span><br><span class="line">    return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br><span class="line"></span><br><span class="line">//尾递归优化，只保留一个调用记录，复杂度 O(1) 。</span><br><span class="line">function factorial(n, total = 1) &#123;</span><br><span class="line">    if (n === 1) return total;</span><br><span class="line">    return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips：把所有用到的内部变量改写成函数的参数</p>
</blockquote>
</li>
</ol>
<p><br><br></p>
<h3 id="六、-数组的扩展"><a href="#六、-数组的扩展" class="headerlink" title="六、- 数组的扩展"></a>六、- 数组的扩展</h3><ol>
<li><p>扩展运算符（<code>...[]</code>）的应用</p>
<ul>
<li>转成参数序列</li>
<li><p>复制数组</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1.concat(); //es5</span><br><span class="line"></span><br><span class="line">const a3 = [...a1];     //es6</span><br><span class="line">const [...a4] = a1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并数组 <code>[...arr1, ...arr2, ...arr3]</code> （浅拷贝）</p>
</li>
<li>解构赋值 <code>const [first, ...rest] = [1, 2, 3, 4, 5]</code></li>
<li><p>正确返回字符长度 <code>[...str].length</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;x\uD83D\uDE80y&apos;.length // 4</span><br><span class="line">[...&apos;x\uD83D\uDE80y&apos;].length // 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 <code>Iterator</code> 接口的对象.<br>任何 <code>Iterator</code> 接口的对象，都可以用扩展运算符转为真正的数组。<br>对于那些没有部署 <code>Iterator</code>接口的类似数组的对象,使用<code>Array.from(arrayLike)</code>，实际上任何有length属性的对象，都可以通过Array.from方法转为数组。</p>
</li>
</ul>
</li>
<li><p><code>Array.from()</code>:</p>
<ul>
<li>用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map）。</li>
<li><p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arrayLike, x =&gt; x * x);</span><br><span class="line">// 等同于</span><br><span class="line">Array.from(arrayLike).map(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line">Array.from([1, 2, 3], (x) =&gt; x * x)</span><br><span class="line">// [1, 4, 9]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><code>Array.of()</code>:</p>
<ul>
<li>用于将一组值，转换为数组。</li>
<li><p>为了弥补构造函数<code>Array()</code>的不足</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//参数个数不一样行为不同</span><br><span class="line">Array() // []</span><br><span class="line">Array(3) // [, , ,]</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br></pre></td></tr></table></figure>
<p> <code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
</li>
</ul>
</li>
<li><p>数组实例的 <code>copyWithin()</code></p>
<ul>
<li>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。。</li>
<li><code>Array.prototype.copyWithin(target, start = 0, end = this.length)</code></li>
</ul>
</li>
<li><p>数组实例的 <code>fill()</code> </p>
<ul>
<li>可用于填充数组，数组中已有的元素，会被全部抹去。</li>
<li><p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;].fill(7, 1, 3)</span><br><span class="line">// [&apos;a&apos;, 7, 7, &apos;d&apos;]</span><br><span class="line"></span><br><span class="line">//&gt; 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</span><br><span class="line">let arr = new Array(3).fill([]);</span><br><span class="line">arr[0].push(5);</span><br><span class="line">// arr = [[5], [5], [5]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>数组实例的 <code>entries()</code>，<code>keys()</code> 和 <code>values()</code>   </p>
<ul>
<li><p>用<code>for...of</code>循环进行遍历，keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">    console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;1</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数组实例的 <code>includes()</code></p>
<ul>
<li><p>表示某个数组是否包含给定的值(第二个参数表示搜索的起始位置)，与字符串的includes方法类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(3, 3)   // false</span><br><span class="line">[1, 2, 3].includes(3, -1)  // true</span><br><span class="line">[1, 2, [3]].includes([3])  // false</span><br><span class="line">[NaN].includes(NaN)        // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数组实例的 <code>flat()</code>，<code>flatMap()</code> —Chrome无此方法(2018/8/21)</p>
<ul>
<li><p><code>flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。参数：想要拉平的层数，默认为1。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> [1, 2, [3, [4, 5]]].flat()</span><br><span class="line"> // [1, 2, 3, [4, 5]]</span><br><span class="line"> </span><br><span class="line"> //如果原数组有空位，flat()方法会跳过空位。</span><br><span class="line">[1, 2, , 4, 5].flat()</span><br><span class="line"> // [1, 2, 4, 5]</span><br><span class="line"> </span><br><span class="line"> [1, [2, [3]]].flat(Infinity) //Infinity:不管有多少层嵌套，都要转成一维数组</span><br><span class="line"> // [1, 2, 3]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flatMap()</code> 方法对原数组的每个成员执行一个函数,然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。传入函数（类似<code>map</code>）,只能展开一层</p>
</li>
</ul>
</li>
<li><p>数组的空位的处理</p>
<ul>
<li><p>ES5：</p>
<ul>
<li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li>
</ul>
</li>
<li><p>ES6：</p>
<ul>
<li><p>明确将空位转为undefined</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[&apos;a&apos;,,&apos;b&apos;]]</span><br><span class="line">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h3 id="七、-对象的扩展"><a href="#七、-对象的扩展" class="headerlink" title="七、- 对象的扩展"></a>七、- 对象的扩展</h3><ol>
<li>简写<code>{foo} === {foo: foo}</code></li>
<li><p><code>Object.is()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://es6.ruanyifeng.com/#docs/object" target="_blank" rel="noopener">对象详情</a></p>
</li>
</ol>
<p><br><br></p>
<h3 id="八、Symbol类型：表示独一无二的值"><a href="#八、Symbol类型：表示独一无二的值" class="headerlink" title="八、Symbol类型：表示独一无二的值"></a>八、Symbol类型：表示独一无二的值</h3><ol>
<li>Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</li>
<li>Symbol 值不能与其他类型的值进行运算，会报错。</li>
<li>Symbol 值可以显式转为字符串|布尔值但不能转为数值。</li>
<li>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</li>
</ol>
<p><br><br></p>
<h3 id="九、-Set-和-Map-数据结构"><a href="#九、-Set-和-Map-数据结构" class="headerlink" title="九、 Set 和 Map 数据结构"></a>九、 Set 和 Map 数据结构</h3><ol>
<li><p>Set: 它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1, 2, 3, 4, 4, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br><span class="line"></span><br><span class="line">//在 Set 内部，两个NaN是相等。</span><br><span class="line">//另外，两个对象总是不相等的。</span><br></pre></td></tr></table></figure>
<ul>
<li>add(value)：添加某个值，返回 Set 结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
</li>
<li><p>WeakSet :与 Set 类似,但 <code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值。<br>没有size属性，没有办法遍历它的成员。</p>
</li>
<li><p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line">const k1 = [&apos;a&apos;];</span><br><span class="line">const k2 = [&apos;a&apos;];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, 111)</span><br><span class="line">.set(k2, 222);</span><br><span class="line"></span><br><span class="line">map.get(k1) // 111</span><br><span class="line">map.get(k2) // 222</span><br></pre></td></tr></table></figure>
</li>
<li><p>WeakMap :与Map结构类似，也是用于生成键值对的集合。</p>
<ul>
<li><p>区别：</p>
<ul>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>
<li><p>WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const wm = new WeakMap();</span><br><span class="line"></span><br><span class="line">const element = document.getElementById(&apos;example&apos;);</span><br><span class="line"></span><br><span class="line">wm.set(element, &apos;some information&apos;);</span><br><span class="line">wm.get(element) // &quot;some information&quot;</span><br><span class="line">/*</span><br><span class="line">先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，</span><br><span class="line">并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element</span><br><span class="line">的引用就是弱引用，不会被计入垃圾回收机制即DOM节点对象的引用计数是1，而不是2。</span><br><span class="line">可以有效防止内存泄漏。</span><br><span class="line">（WeakMap 的另一个用处是部署私有属性。如果删除实例，它们也就随之消失）</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h3 id="十、-Proxy"><a href="#十、-Proxy" class="headerlink" title="十、 Proxy"></a>十、 Proxy</h3><ol>
<li><p>含义：在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。（代理器）</p>
</li>
<li><p><code>new Proxy(target, handler)</code></p>
</li>
<li><p>Proxy支持的拦截操作</p>
<ol>
<li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>
<li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>
<li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
<li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ol>
</li>
</ol>
<p><br><br></p>
<h3 id="十一、-Reflect"><a href="#十一、-Reflect" class="headerlink" title="十一、 Reflect"></a>十一、 Reflect</h3><ol>
<li>从Reflect对象上可以拿到语言内部的方法。</li>
<li><p>13个静态方法</p>
<ul>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li><p>Reflect.get(target, name, receiver)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const myObject = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: 2,</span><br><span class="line">  get baz() &#123;</span><br><span class="line">    return this.foo + this.bar;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">console.log(Reflect.get(myObject, &apos;foo&apos;)) // 1</span><br><span class="line">console.log(Reflect.get(myObject, &apos;bar&apos;)) // 2</span><br><span class="line">console.log(Reflect.get(myObject, &apos;baz&apos;)) // 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>- Reflect.set(target, name, value, receiver)

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myObject.foo // 1</span><br><span class="line"></span><br><span class="line">Reflect.set(myObject, &apos;foo&apos;, 2);</span><br><span class="line">myObject.foo // 2</span><br></pre></td></tr></table></figure>


- Reflect.defineProperty(target, name, desc)

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 新写法</span><br><span class="line">Reflect.defineProperty(MyDate, &apos;now&apos;, &#123;</span><br><span class="line">  value: new Date()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(MyDate.now)</span><br></pre></td></tr></table></figure>


- Reflect.deleteProperty(target, name)
- Reflect.has(target, name)
- Reflect.ownKeys(target)
- Reflect.isExtensible(target)
- Reflect.preventExtensions(target)
- Reflect.getOwnPropertyDescriptor(target, name)

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const myObject = &#123;&#125;;</span><br><span class="line">Reflect.defineProperty(myObject, &apos;hidden&apos;, &#123;</span><br><span class="line">  value: true,</span><br><span class="line">  writable:true,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const theDescriptor = Reflect.getOwnPropertyDescriptor(myObject,&apos;hidden&apos;);</span><br><span class="line">console.log(theDescriptor)</span><br><span class="line">//&#123;value: true, writable: true, enumerable: false, configurable: false&#125;</span><br><span class="line">myObject.hidden = 1</span><br><span class="line">console.log(myObject) //&#123;hidden: 1&#125;</span><br></pre></td></tr></table></figure>


- Reflect.getPrototypeOf(target)
- Reflect.setPrototypeOf(target, prototype)
</code></pre><ol start="3">
<li><p>实例：使用 Proxy 实现观察者模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const queuedObservers = new Set();</span><br><span class="line"></span><br><span class="line">const observe = fn =&gt; queuedObservers.add(fn);</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);</span><br><span class="line"></span><br><span class="line">function set(target, key, value, receiver) &#123;</span><br><span class="line">  const result = Reflect.set(target, key, value, receiver);</span><br><span class="line">  queuedObservers.forEach(observer =&gt; observer());</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person = observable(&#123;</span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">function print() &#123;</span><br><span class="line">  console.log(`$&#123;person.name&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observe(print);</span><br><span class="line">person.name = &apos;李四&apos;;  //李四</span><br><span class="line">person.name = &apos;33&apos;;     //33</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者—这跟vue很相似</p>
</blockquote>
</li>
</ol>
<p><br><br></p>
<h3 id="十二、-Promise-对象"><a href="#十二、-Promise-对象" class="headerlink" title="十二、 Promise 对象"></a>十二、 Promise 对象</h3><ol>
<li><p>含义：Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
</li>
<li><p><code>Promise.prototype.then()</code>：<br>then方法返回的是一个新的Promise实例。因此可以采用链式写法</p>
</li>
<li><p><code>Promise.prototype.catch()</code>：<br><code>.then(null, rejection)</code>的别名,一般建议总是使用<code>catch</code>方法。<code>catch</code>方法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。</p>
<blockquote>
<p>如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码</p>
</blockquote>
</li>
<li><p><code>Promise.prototype.finally()</code>：<br>不管 Promise 对象最后状态如何，都会执行的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  // 语句</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">    return result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    //...</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p><code>Promise.all()</code>：<br><code>const p = Promise.all([p1, p2, p3]);</code></p>
<blockquote>
<p>注意：</p>
<ul>
<li>（<code>Promise.all</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</li>
<li>只有所有的状态都变成<code>fulfilled</code>，返回值组成一个数组，传递给回调函数，<br>或者有一个变为<code>rejected</code>，被<code>reject</code>的实例的返回值才会继续传递给回调函数。</li>
</ul>
</blockquote>
</li>
<li><p><code>Promise.race()</code>：<br><code>const p = Promise.race([p1, p2, p3]);</code><br>只要有一个状态改变就。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//当接口五秒内未返回就报超时错误</span><br><span class="line">const p = Promise.race([</span><br><span class="line">  fetch(&apos;/resource-that-may-take-a-while&apos;),</span><br><span class="line">  new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(console.log)</span><br><span class="line">.catch(console.error);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li><p><code>Promise.resolve()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;foo&apos;)</span><br><span class="line">// 等价于（可以将现有对象转成Promise对象）</span><br><span class="line">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</span><br></pre></td></tr></table></figure>
<ul>
<li>参数是个Promise 实例：不做修改直接返回这个实例</li>
<li>参数是个具有then方法的对象：先转Promise然后立即执行then方法</li>
<li>参数不是具有then方法的对象，或根本就不是对象：返回状态为resolved的Promise对象<br>不带有任何参数：直接返回一个resolved状态的 Promise 对象。</li>
</ul>
</li>
<li><p><code>Promise.reject()</code>：<br>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p>
</li>
<li><p><code>Promise.try()</code>：<br>不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它时。</p>
<blockquote>
<p>解决方案1 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(&apos;now&apos;);</span><br><span class="line">(async () =&gt; f())()</span><br><span class="line">console.log(&apos;next&apos;)</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>解决方案2 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const f = () =&gt; console.log(&apos;now&apos;);</span><br><span class="line">(</span><br><span class="line">  () =&gt; new Promise(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line">console.log(&apos;next&apos;);</span><br><span class="line">// now</span><br><span class="line">// next</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p><br><br><br></p>
<h3 id="十三、Iterator-和-for…of-循环"><a href="#十三、Iterator-和-for…of-循环" class="headerlink" title="十三、Iterator 和 for…of 循环"></a>十三、Iterator 和 for…of 循环</h3><h4 id="①-Iterator"><a href="#①-Iterator" class="headerlink" title="①. Iterator"></a>①. Iterator</h4><ol>
<li><p>凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。<br>原生具备<code>Iterator</code>接口的数据结构 (可以用for…of遍历它们）：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象<br><br></li>
</ul>
</li>
<li><p>默认调用<code>Symbol.iterator</code>方法的情况</p>
<ul>
<li>对数组和 Set 结构进行解构赋值时</li>
<li>使用扩展运算符（…）</li>
<li><p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const generator = function* () &#123;</span><br><span class="line">  yield* [1,2];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() // &#123; value: 1, done: false &#125;</span><br><span class="line">iterator.next() // &#123; value: 2, done: false &#125;</span><br><span class="line">iterator.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的遍历会调用遍历器接口</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li>
<li>Promise.all()</li>
<li>Promise.race()<br>…….</li>
</ul>
</li>
</ul>
</li>
<li>字符串是一个类似数组的对象，也原生具有 Iterator 接口。 </li>
<li><p>遍历器对象的 return()</p>
<blockquote>
<p>可以触发return的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 情况一:break</span><br><span class="line">for (let line of readLinesSync(fileName)) &#123;</span><br><span class="line">  console.log(line);</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二:Error</span><br><span class="line">for (let line of readLinesSync(fileName)) &#123;</span><br><span class="line">  console.log(line);</span><br><span class="line">  throw new Error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<ul>
<li>情况一输出文件的第一行以后，就会执行return方法，关闭这个文件；</li>
<li>情况二会在执行return方法关闭文件之后，再抛出错误。</li>
</ul>
</li>
</ol>
<p><br></p>
<h4 id="②-for…of-循环"><a href="#②-for…of-循环" class="headerlink" title="②. for…of 循环"></a>②. for…of 循环</h4><ol>
<li><code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</li>
<li><code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。<br><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let arr = [3, 5, 7];</span><br><span class="line">arr.foo = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (let i in arr) &#123;</span><br><span class="line">  console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i of arr) &#123;</span><br><span class="line">  console.log(i); //  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h4><ol>
<li>Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组(<code>[k,v]</code>)</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li>对于没有Iterator接口的类数组对象：使用<code>Array.from</code>方法将其转为数组。</li>
</ol>
<p><br><br></p>
<h3 id="十四、Generator-函数的语法"><a href="#十四、Generator-函数的语法" class="headerlink" title="十四、Generator 函数的语法"></a>十四、Generator 函数的语法</h3><ol>
<li><p>Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const myIterable = &#123;&#125;</span><br><span class="line">myIterable[Symbol.iterator] = function* () &#123;</span><br><span class="line">  yield 1</span><br><span class="line">  yield 2</span><br><span class="line">  yield 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log([...myIterable])  // [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p><br></p>
</li>
<li>注意：<ul>
<li><code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</li>
<li><code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</li>
<li><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。<br><br><br></li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><code>next</code> 方法的参数</p>
<ul>
<li><code>next</code>方法可以带一个参数，该参数就会被当作<strong>上一个<code>yield</code>表达式的返回值</strong>。<br>也就是说：可以在 <code>Generator</code>函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。<ul>
<li>注意: 由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的<br><br></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Generator.prototype.throw()</code>:</p>
<ul>
<li>只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</li>
<li>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。<br><br>   </li>
</ul>
</li>
<li><p><code>Generator.prototype.return()</code>:</p>
<ul>
<li>可以返回给定的值，并且终结遍历 Generator 函数。<br><br></li>
</ul>
</li>
<li><p><code>yield*</code> 表达式：为了说明<code>yield</code>表达式后面跟的是一个遍历器对象时加<code>*</code><br><br></p>
</li>
<li><p><code>Generator</code> 函数的<code>this</code>:</p>
<ul>
<li>Generator 函数总是返回遍历器对象而不是<code>this</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* gen() &#123;</span><br><span class="line">  this.a = 1;</span><br><span class="line">  yield this.b = 2;</span><br><span class="line">  yield this.c = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function F() &#123;</span><br><span class="line">  return gen.call(gen.prototype);//&lt;--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = new F();</span><br><span class="line"></span><br><span class="line">f.next();  // Object &#123;value: 2, done: false&#125;</span><br><span class="line">f.next();  // Object &#123;value: 3, done: false&#125;</span><br><span class="line">f.next();  // Object &#123;value: undefined, done: true&#125;</span><br><span class="line"></span><br><span class="line">f.a // 1</span><br><span class="line">f.b // 2</span><br><span class="line">f.c // 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
</li>
<li><p><code>Generator</code> </p>
<ul>
<li>与状态机:完美管理状态</li>
<li>协程：既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</li>
<li>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。</li>
<li>与普通线程差异：<ul>
<li>同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。</li>
<li>普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。              </li>
</ul>
</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h3 id="十五、Generator-函数的异步应用"><a href="#十五、Generator-函数的异步应用" class="headerlink" title="十五、Generator 函数的异步应用"></a>十五、Generator 函数的异步应用</h3><ol>
<li><p>传统方法 </p>
<ul>
<li><p>回调函数 -&gt;（callback hell）强耦合</p>
</li>
<li><p>事件监听</p>
</li>
<li><p>发布/订阅</p>
</li>
<li><p><code>Promise</code>对象 -&gt;代码冗余，原来的任务被<code>Promise</code>包装了一下，一堆then，原来的语义变得很不清楚。<br><br></p>
</li>
</ul>
</li>
<li><p><code>Thunk</code> 函数:是“传名调用”的一种实现策略，用来替换某个表达式。<br> /JavaScript 语言是传值调用,以下是个自执行器（thunkify、co模块、)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">   //实现自执行</span><br><span class="line">  function thunkify(fn) &#123;</span><br><span class="line">     return function() &#123;</span><br><span class="line">       var args = new Array(arguments.length);</span><br><span class="line">       var ctx = this;</span><br><span class="line">   		</span><br><span class="line">       for (var i = 0; i &lt; args.length; ++i) &#123;</span><br><span class="line">         args[i] = arguments[i];</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       return function (done) &#123;</span><br><span class="line">         var called;</span><br><span class="line">         args.push(function () &#123;</span><br><span class="line">           if (called) return;</span><br><span class="line">           called = true;</span><br><span class="line">           done.apply(null, arguments);</span><br><span class="line">         &#125;);</span><br><span class="line">   </span><br><span class="line">         try &#123;</span><br><span class="line">           fn.apply(ctx, args);</span><br><span class="line">         &#125; catch (err) &#123;</span><br><span class="line">           done(err);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">      </span><br><span class="line">    const ft = (n,cb) =&gt;cb(n)</span><br><span class="line">    const CB = thunkify(ft)  </span><br><span class="line">       </span><br><span class="line">       //实现自执行</span><br><span class="line">       function run(fn) &#123;</span><br><span class="line">         var gen = fn()</span><br><span class="line">       </span><br><span class="line">         function next(err, data) &#123;</span><br><span class="line">           var result = gen.next(data)</span><br><span class="line">           console.log(result)</span><br><span class="line">           if (result.done) return;</span><br><span class="line">           result.value(next)</span><br><span class="line">         &#125;</span><br><span class="line">       </span><br><span class="line">         next()</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   </span><br><span class="line">       const g = function* ()&#123;</span><br><span class="line">         var f1 = yield CB(&apos;aaaaaa&apos;)</span><br><span class="line">         var f2 = yield CB(&apos;bbbbbb&apos;)</span><br><span class="line">         // ...</span><br><span class="line">         var fn = yield CB(&apos;nnnnnn&apos;)</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       run(g)</span><br><span class="line">   ```     </span><br><span class="line">   &lt;br/&gt;</span><br><span class="line">  </span><br><span class="line">3. CO模块</span><br><span class="line">   1. 原理：Generator 就是一个异步操作的容器。它的自动执行需要一种机制，**当异步操作有了结果**，能够自动交回执行权。以下两种方法可以做到这一点：</span><br><span class="line">       - 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</span><br><span class="line">       - Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。</span><br><span class="line">       &lt;br&gt;</span><br><span class="line">   2. 基于 Promise 对象的自动执行</span><br></pre></td></tr></table></figure>
<p>function run(gen){<br>  var g = gen();</p>
<p>  function next(data){</p>
<pre><code>var result = g.next(data)
console.log(result)
if (result.done) return result.value
result.value.then(function(data){
  next(data);
});
</code></pre><p>  }</p>
<p>  next();<br>}</p>
<p>//需要返回promise 然后链式自执行<br>const CO = (data) =&gt; new Promise((resolve)=&gt; resolve(data))<br>const g = function* (){<br>  var f1 = yield CO(‘aaaaaa’)<br>  var f2 = yield CO(‘bbbbbb’)<br>  // …<br>  var fn = yield CO(‘nnnnnn’)<br>}</p>
<p>run(g)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    3. 处理并发的异步操作</span><br><span class="line">     - co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</span><br><span class="line">     </span><br><span class="line">    4. 实例：处理 Stream</span><br><span class="line">&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 十六、async 函数</span><br><span class="line"> 1. Generator 函数的语法糖</span><br><span class="line">    - 改进</span><br><span class="line">     - （1）async函数自带执行器。</span><br><span class="line">     - （2）更广的适用性</span><br><span class="line">        `co模块`约定，`yield`命令后面只能是`Thunk`函数或`Promise`对象，而`async`函数的`await`命令后面，可以是`Promise`对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）</span><br><span class="line">     - （3）返回值是 `Promise`。</span><br><span class="line">        `Generator` 函数的返回值是 `Iterator` 对象</span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 2. 注意点</span><br><span class="line">    1. async函数内部`return`语句返回的值，会成为`then`方法回调函数的参数。</span><br><span class="line">    2. async函数内部抛出错误，会导致返回的`Promise`对象变为`reject`状态。抛出的错误对象会被`catch`方法回调函数接收到。</span><br><span class="line">    3. 只要一个`await`语句后面的`Promise`变为`reject`，那么整个`async`函数都会中断执行。 =&gt; 想继续执行 可以吧代码放在`try...catch`中。</span><br><span class="line">    4. await命令只能用在async函数之中，如果用在普通函数，就会报错。</span><br><span class="line">     - forEach/Map中使用async也会出问题 :</span><br></pre></td></tr></table></figure>
<p> // scope B<br>array.forEach(async function(item) { // scope A<br>  await wait(1000);<br>});<br>/<em><br><code>Scope B</code> 部分的代码并不会等待 <code>Scope A</code> 中的 <code>async/await</code> 执行完后继续执行后面的代码，相反，他会立刻执行后面的代码
</em>/</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     - 正确的写法是采用for循环、</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"> 3. 并发执行</span><br></pre></td></tr></table></figure>
<p>// 写法一<br>let [foo, bar] = await Promise.all([getFoo(), getBar()]);</p>
<p>// 写法二<br>let fooPromise = getFoo();<br>let barPromise = getBar();<br>let foo = await fooPromise;<br>let bar = await barPromise;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">4. `for await...of`:遍历异步的 Iterator 接口。</span><br></pre></td></tr></table></figure>
<p>for await (const chunk of readStream) {</p>
<pre><code>console.log(&apos;&gt;&gt;&gt; &apos;+chunk);
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"> 5. 异步 Generator 函数</span><br><span class="line">    - 在头部加async 标志，此时即可返回一个Promise</span><br><span class="line"> </span><br><span class="line">&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 十七、Class 的基本语法</span><br><span class="line"> 1. `constructor` 方法</span><br><span class="line">    - 通过new命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。</span><br><span class="line">    - `constructor`方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 2. `class Foo &#123;&#125;`不存在声明提升 </span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 3. 私有方法和私有属性 </span><br><span class="line">    - 函数名加下划线（仅为命名方法，外部仍可调用） </span><br><span class="line">    - 将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</span><br></pre></td></tr></table></figure>
<p>class Widget {<br>  foo (baz) {</p>
<pre><code>bar.call(this, baz);
</code></pre><p>  }<br>  // …<br>}</p>
<p>function bar(baz) {<br>  return this.snaf = baz;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 利用`Symbol`值的唯一性，将私有方法的名字命名为一个Symbol值。</span><br></pre></td></tr></table></figure>
<p>const bar = Symbol(‘bar’)<br>const snaf = Symbol(‘snaf’)</p>
<p>export default class myClass{<br>  foo(baz) {</p>
<pre><code>this[bar](baz);
</code></pre><p>  }</p>
<p>  // 私有方法<br>  <a href="baz">bar</a> {</p>
<pre><code>return this[snaf] = baz;
</code></pre><p>  }<br>  // …<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;br/&gt;</span><br><span class="line">4. this 的指向</span><br><span class="line">   - 当类的方法中有this使用且方法被提取出来单独使用时this会指向方法运行环境导致意料之外的错误</span><br><span class="line">   1. 可以在构造函数中绑定`this.printName = this.printName.bind(this)`</span><br><span class="line">   2. 箭头函数：</span><br></pre></td></tr></table></figure>
<p>constructor() {</p>
<pre><code>this.printName = (name = &apos;there&apos;) =&gt; {
  this.print(`Hello ${name}`)
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 使用Proxy，获取方法的时候，自动绑定this</span><br></pre></td></tr></table></figure>
<p>function selfish (target) {<br>  const cache = new WeakMap();<br>  const handler = {</p>
<pre><code>get (target, key) {
  const value = Reflect.get(target, key);
  if (typeof value !== &apos;function&apos;) {
    return value;
  }
  if (!cache.has(value)) {
    cache.set(value, value.bind(target));
  }
  return cache.get(value);
}
</code></pre><p>  };<br>  const proxy = new Proxy(target, handler);<br>  return proxy;<br>}</p>
<p>const logger = selfish(new Logger());</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;br/&gt;</span><br><span class="line">- Class 的取值函数（getter）和存值函数（setter）</span><br></pre></td></tr></table></figure>
<p>class MyClass {<br>  constructor() {</p>
<pre><code>// ...
</code></pre><p>  }<br>  get prop() {</p>
<pre><code>return &apos;getter&apos;;
</code></pre><p>  }<br>  set prop(value) {</p>
<pre><code>console.log(&apos;setter: &apos;+value);
</code></pre><p>  }<br>}</p>
<p>let inst = new MyClass();</p>
<p>inst.prop = 123;<br>// setter: 123</p>
<p>inst.prop<br>// ‘getter’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    &lt;/br&gt;</span><br><span class="line">    - Class 的静态方法</span><br><span class="line">        在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用</span><br><span class="line">  &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 十八、Class 的继承</span><br><span class="line"> 1. 子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用`super`方法，子类就得不到`this`对象。 =&gt;`constructor`不写默认 有`super(...args)`</span><br><span class="line"> </span><br><span class="line"> 2. `Object.getPrototypeOf`：从子类上获取父类</span><br></pre></td></tr></table></figure>
<p>//可以使用这个方法判断，一个类是否继承了另一个类。<br>Object.getPrototypeOf(ColorPoint) === Point<br>// true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">3. `super`:</span><br><span class="line">   - super在B的构造函数中，指向`A.prototype`，所以`super`可以拿到父类原型对象上的实例方法</span><br><span class="line">   - 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</span><br><span class="line"></span><br><span class="line">4. 原生构造函数的继承</span><br><span class="line">   - Boolean()</span><br><span class="line">   Number()</span><br><span class="line">   String()</span><br><span class="line">   Array()</span><br><span class="line">   Date()</span><br><span class="line">   Function()</span><br><span class="line">   RegExp()</span><br><span class="line">   Error()</span><br><span class="line">   Object()</span><br><span class="line">   &gt;原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</span><br><span class="line">   &gt;`extends`关键字不仅可以用来继承类，还可以用来继承原生的构造函数!</span><br><span class="line"></span><br><span class="line">5. Mixin 模式的实现(多个对象合成一个新的对象)</span><br></pre></td></tr></table></figure>
<p>function mix(…mixins) {<br>  class Mix {}</p>
<p>  for (let mixin of mixins) {</p>
<pre><code>copyProperties(Mix.prototype, mixin); // 拷贝实例属性
copyProperties(Mix.prototype, Reflect.getPrototypeOf(mixin)); // 拷贝原型属性
</code></pre><p>  }</p>
<p>  return Mix;<br>}</p>
<p>function copyProperties(target, source) {<br>  for (let key of Reflect.ownKeys(source)) {</p>
<pre><code>if ( key !== &quot;constructor&quot;
  &amp;&amp; key !== &quot;prototype&quot;
  &amp;&amp; key !== &quot;name&quot;
) {
  let desc = Object.getOwnPropertyDescriptor(source, key);
  Object.defineProperty(target, key, desc);
}
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 十九、修饰器（提案）</span><br><span class="line"> 1. 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升</span><br><span class="line"> 2. 详见&gt;&gt;[ES6-修饰器][4]</span><br><span class="line"></span><br><span class="line"> &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 二十、Module 的语法</span><br><span class="line"> 1. 注意点</span><br><span class="line">    - import在静态解析阶段执行，所以它是一个模块之中最早执行的。</span><br><span class="line">    - import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</span><br></pre></td></tr></table></figure>
<p>// 报错<br>import { ‘f’ + ‘oo’ } from ‘my_module’;</p>
<p>// 报错<br>let module = ‘my_module’;<br>import { foo } from module;</p>
<p>// 报错<br>if (x === 1) {<br>  import { foo } from ‘module1’;<br>} else {<br>  import { foo } from ‘module2’;<br>}<br>//在静态分析阶段，这些语法都是没法得到值的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. `export default`命令其实只是输出一个叫做default的变量</span><br><span class="line">3. export 与 import 的复合写法</span><br></pre></td></tr></table></figure>
<p>//foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口<br>export { foo, bar } from ‘my_module’<br>//&gt;可以用来合并一些模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 4. 提案：import()函数 =&gt; 用来动态加载模块 返回Promise</span><br><span class="line"></span><br><span class="line"> &lt;br/&gt;&lt;br/&gt;</span><br><span class="line">### 二十、Module 的加载实现</span><br><span class="line"> 1. 浏览器加载</span><br><span class="line">    - 传统方法</span><br><span class="line">     -  defer :&quot;渲染完再执行&quot; , 多个defer脚本,会按照它们在页面出现的顺序加载。</span><br><span class="line">     -  async :&quot;下载完就执行&quot; , 多个async脚本,不能保证加载顺序。</span><br><span class="line">    - 加载 ES6 模块</span><br><span class="line">     - `&lt;script type=&quot;module&quot; src=&quot;./...js&quot;&gt;&lt;/script&gt;`:此时行为与defer相同</span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 2. ES6 模块与 CommonJS 模块的差异</span><br><span class="line">     - CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</span><br><span class="line">     - CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</span><br><span class="line"> &lt;br/&gt;</span><br><span class="line"> 3. Node 加载</span><br><span class="line">    - Node 有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    - Node 要求 ES6 模块采用.mjs后缀文件名。(新版)</span><br></pre></td></tr></table></figure>
<p>$ node –experimental-modules my-app.mjs<br><code>`</code></p>
<ul>
<li>内部变量差异<ul>
<li>ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块。</li>
<li>ES6不存在这些顶层变量：<ol>
<li>arguments</li>
<li>require</li>
<li>module</li>
<li>exports</li>
<li>__filename</li>
<li>__dirname<br><br>  </li>
</ol>
</li>
</ul>
</li>
<li>ES6 模块加载 CommonJS 模块<ul>
<li>Node 的import命令加载 CommonJS 模块，Node 会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>{ default: module.exports }</code></li>
<li>import命令加载 CommonJS 模块时，不允许采用解构的写法，改为整体输入<br><br>  </li>
</ul>
</li>
<li>CommonJS 模块加载 ES6 模块<ul>
<li>不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</li>
</ul>
</li>
</ul>
<p><br></p>
</li>
<li>循环加载<ul>
<li>CommonJS 模块加载原理<ul>
<li>require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</li>
<li>CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li>
<li>由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。<br><br></li>
</ul>
</li>
<li>ES6 模块的循环加载<ul>
<li>与CommonJS不同：变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</li>
<li>a 引用 b,b中引用a,执行到b中对a引用时会认为a已经存在，继续往下执行</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="赵泽清 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="赵泽清 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/27/2018-5-27-Redux实践——减少样板代码/" rel="next" title="Redux实践——减少样板代码">
                <i class="fa fa-chevron-left"></i> Redux实践——减少样板代码
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/02/前端面试题总结/" rel="prev" title="前端面试题总结">
                前端面试题总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="赵泽清">
            
              <p class="site-author-name" itemprop="name">赵泽清</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_36571602" target="_blank" title="Blog">
                      
                        <i class="fa fa-fw fa-rss"></i>Blog</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhaozeq" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhaozeq@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、-变量赋值与解构"><span class="nav-number">1.</span> <span class="nav-text">一、 变量赋值与解构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、-字符串拓展"><span class="nav-number">2.</span> <span class="nav-text">二、- 字符串拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、-正则拓展"><span class="nav-number">3.</span> <span class="nav-text">三、- 正则拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、-数值的拓展"><span class="nav-number">4.</span> <span class="nav-text">四、- 数值的拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、-函数的扩展"><span class="nav-number">5.</span> <span class="nav-text">五、- 函数的扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、-数组的扩展"><span class="nav-number">6.</span> <span class="nav-text">六、- 数组的扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、-对象的扩展"><span class="nav-number">7.</span> <span class="nav-text">七、- 对象的扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八、Symbol类型：表示独一无二的值"><span class="nav-number">8.</span> <span class="nav-text">八、Symbol类型：表示独一无二的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九、-Set-和-Map-数据结构"><span class="nav-number">9.</span> <span class="nav-text">九、 Set 和 Map 数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十、-Proxy"><span class="nav-number">10.</span> <span class="nav-text">十、 Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一、-Reflect"><span class="nav-number">11.</span> <span class="nav-text">十一、 Reflect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十二、-Promise-对象"><span class="nav-number">12.</span> <span class="nav-text">十二、 Promise 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十三、Iterator-和-for…of-循环"><span class="nav-number">13.</span> <span class="nav-text">十三、Iterator 和 for…of 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#①-Iterator"><span class="nav-number">13.1.</span> <span class="nav-text">①. Iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#②-for…of-循环"><span class="nav-number">13.2.</span> <span class="nav-text">②. for…of 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set和Map"><span class="nav-number">13.3.</span> <span class="nav-text">Set和Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">13.4.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十四、Generator-函数的语法"><span class="nav-number">14.</span> <span class="nav-text">十四、Generator 函数的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十五、Generator-函数的异步应用"><span class="nav-number">15.</span> <span class="nav-text">十五、Generator 函数的异步应用</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赵泽清</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="/css/gitment.css">
        <script src="/lib/gitment/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: '1533830400000', 
            owner: 'zhaozeq',
            repo: 'zhaozeq.github.io',
            
            lang: "zh-CN" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '340da55620308337b86a249d541a937c978db4dd',
            
                client_id: 'bd7144cfd2b00a4da63f'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
